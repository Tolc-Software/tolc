{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Tolc aims to make it as simple as possible to use C++ from other languages. Tolc does not require you to change any part of your existing C++ but simply reads your headers and automatically generates the correct bindings. Tolc is easily integrated into any C++ project, either via the provided CMake Interface, or directly as a simple executable. Tolc is available on Windows, MacOS, and Debian flavours of Linux. From here you can try any of the supported languages: Python WebAssembly","title":"Introduction"},{"location":"#introduction","text":"Tolc aims to make it as simple as possible to use C++ from other languages. Tolc does not require you to change any part of your existing C++ but simply reads your headers and automatically generates the correct bindings. Tolc is easily integrated into any C++ project, either via the provided CMake Interface, or directly as a simple executable. Tolc is available on Windows, MacOS, and Debian flavours of Linux. From here you can try any of the supported languages: Python WebAssembly","title":"Introduction"},{"location":"FAQ/","text":"How do I specialize a templated function/class? I get ImportError: <module>: undefined symbol: _ZN15<class>1<variable>E when I import my module I get a link error while building WebAssembly on Windows with Visual Studio How do I specialize a templated function/class? Given a simple function, you can create a specialization on the form: template returnType functionName(arguments); For example: #include <string> #include <vector> template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string); template std::vector<std::string> getSomething(std::vector<std::string>); Same for classes: template <typename T> class MyClass { public: T fun(T type) { return type; } }; template class MyClass<int>; Then from python they are available as: import MyLib # Functions are processed as overloaded, so no name change print(MyLib.getSomething(\"Tell tolc I said hi\")) print(MyLib.getSomething(something=[\"Or\", \"as\", \"an\", \"array\"]) # Class specializations have type postfixes my_class_int = MyLib.MyClass_int() print(my_class_int.fun(42)) For more information about type postfixes see the Template Naming Convention page . I get ImportError: <module>: undefined symbol: _ZN15<class>1<variable>E when I import my module It might be that there is a static variable not instantiated in a source file. Consider the example: class Example { public: static int const i = 5; }; On its own this will generate an ImportError . To avoid the error, instantiate the static variable inside a .cpp file as: int const Example::i; For more information you can read about static member declaration/instantiation on cppreference , or a discussion on this topic in the pybind repository . I get a link error while building WebAssembly on Windows with Visual Studio At the time of writing there is only experimental support for the Visual Studio generator for Emscripten . If you see error such as: shell LINK : warning LNK4044: unrecognized option '/-default-obj-ext'; ignored [MyProject.vcxproj] LINK : fatal error LNK1104: cannot open file '.obj' [MyProject.vcxproj] cl : command line warning D9002: ignoring unknown option '-g' [MyProject_wasm.vcxproj] myLib.cpp shell Then consider using the Ninja generator. It is the default on Windows with Visual Studio .","title":"FAQ"},{"location":"FAQ/#how-do-i-specialize-a-templated-functionclass","text":"Given a simple function, you can create a specialization on the form: template returnType functionName(arguments); For example: #include <string> #include <vector> template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string); template std::vector<std::string> getSomething(std::vector<std::string>); Same for classes: template <typename T> class MyClass { public: T fun(T type) { return type; } }; template class MyClass<int>; Then from python they are available as: import MyLib # Functions are processed as overloaded, so no name change print(MyLib.getSomething(\"Tell tolc I said hi\")) print(MyLib.getSomething(something=[\"Or\", \"as\", \"an\", \"array\"]) # Class specializations have type postfixes my_class_int = MyLib.MyClass_int() print(my_class_int.fun(42)) For more information about type postfixes see the Template Naming Convention page .","title":"How do I specialize a templated function/class?"},{"location":"FAQ/#i-get-importerror-module-undefined-symbol-_zn15class1variablee-when-i-import-my-module","text":"It might be that there is a static variable not instantiated in a source file. Consider the example: class Example { public: static int const i = 5; }; On its own this will generate an ImportError . To avoid the error, instantiate the static variable inside a .cpp file as: int const Example::i; For more information you can read about static member declaration/instantiation on cppreference , or a discussion on this topic in the pybind repository .","title":"I get ImportError: &lt;module&gt;: undefined symbol: _ZN15&lt;class&gt;1&lt;variable&gt;E when I import my module"},{"location":"FAQ/#i-get-a-link-error-while-building-webassembly-on-windows-with-visual-studio","text":"At the time of writing there is only experimental support for the Visual Studio generator for Emscripten . If you see error such as: shell LINK : warning LNK4044: unrecognized option '/-default-obj-ext'; ignored [MyProject.vcxproj] LINK : fatal error LNK1104: cannot open file '.obj' [MyProject.vcxproj] cl : command line warning D9002: ignoring unknown option '-g' [MyProject_wasm.vcxproj] myLib.cpp shell Then consider using the Ninja generator. It is the default on Windows with Visual Studio .","title":"I get a link error while building WebAssembly on Windows with Visual Studio"},{"location":"installing/","text":"Installing The recommended and easiest way is to use the prebuilt binaries under the release page . To download the appropriate one for your platform you can just drop the following lines in your CMake project. # Can be [\"latest\", \"v0.2.0\", ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) When reconfiguring your project, the Tolc CMake interface should be available automatically. Note that this requires CMake 3.15 or later.","title":"Installing"},{"location":"installing/#installing","text":"The recommended and easiest way is to use the prebuilt binaries under the release page . To download the appropriate one for your platform you can just drop the following lines in your CMake project. # Can be [\"latest\", \"v0.2.0\", ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) When reconfiguring your project, the Tolc CMake interface should be available automatically. Note that this requires CMake 3.15 or later.","title":"Installing"},{"location":"usage/","text":"Usage Given that you have installed tolc you should be able to use the CMake interface. Via CMake tolc_create_bindings Example usage: tolc_create_bindings( TARGET MyLib LANGUAGE python OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python-bindings ) This will create a new target called MyLib_python which, when built and available, will be importable from python as import MyLib . The generated python library will be available under ${CMAKE_CURRENT_BINARY_DIR}/tolc , typically build/tolc . To import it, start a python session from the same directory as the built library and import it as you would any other library. An overview of the internal process is described below: Find and combine all public header files based on include directories marked PUBLIC in CMake for target MyLib . Let tolc read the combined header and generate the bindings (in this case they will be available under ${CMAKE_CURRENT_BINARY_DIR}/python-bindings ). Download and make pybind11 available. Create the target MyLib_python and link it to pybind11 aswell as MyLib .","title":"Usage"},{"location":"usage/#usage","text":"Given that you have installed tolc you should be able to use the CMake interface.","title":"Usage"},{"location":"usage/#via-cmake","text":"","title":"Via CMake"},{"location":"usage/#tolc_create_bindings","text":"Example usage: tolc_create_bindings( TARGET MyLib LANGUAGE python OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python-bindings ) This will create a new target called MyLib_python which, when built and available, will be importable from python as import MyLib . The generated python library will be available under ${CMAKE_CURRENT_BINARY_DIR}/tolc , typically build/tolc . To import it, start a python session from the same directory as the built library and import it as you would any other library. An overview of the internal process is described below: Find and combine all public header files based on include directories marked PUBLIC in CMake for target MyLib . Let tolc read the combined header and generate the bindings (in this case they will be available under ${CMAKE_CURRENT_BINARY_DIR}/python-bindings ). Download and make pybind11 available. Create the target MyLib_python and link it to pybind11 aswell as MyLib .","title":"tolc_create_bindings"},{"location":"cmake/interface/","text":"CMake Interface The CMake interface is used to gather information about the library you wish to translate to another language. It is a convenient wrapper around the tolc executable for those who use CMake as their build suite. Tolc CMake interface The main interface is through tolc_create_bindings . Example usage: # This function comes from the tolc package itself # Creates the target example_python that can be imported and used from python tolc_create_bindings( # Target to translate from TARGET example # Language to target LANGUAGE python # Where to put the bindings OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python-bindings ) This assumes there is a CMake target called example that has some include directories marked either PUBLIC or INTERFACE . It will look through these directories for header files (any files ending in .h or .hpp ) and export everything inside them to python via pybind11 . It will then create the target example_python that can be used to compile an importable CPython library. The following figure shows the whole process: Complete example cmake_minimum_required(VERSION 3.15) project(tolc-demo LANGUAGES CXX) add_library(Math src/Demo/demo.cpp) target_include_directories(Math PUBLIC include) set_target_properties( Math PROPERTIES CXX_STANDARD 17 CXX_STANDARD_REQUIRED ON CXX_EXTENSIONS OFF ) include(FetchContent) FetchContent_Declare( tolc_bootstrap GIT_REPOSITORY https://github.com/Tolc-Software/bootstrap-tolc-cmake GIT_TAG main ) FetchContent_MakeAvailable(tolc_bootstrap) get_tolc() tolc_create_bindings( TARGET Math LANGUAGE python OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python-bindings ) You can find full project examples on the Tolc-Software github page .","title":"Interface"},{"location":"cmake/interface/#cmake-interface","text":"The CMake interface is used to gather information about the library you wish to translate to another language. It is a convenient wrapper around the tolc executable for those who use CMake as their build suite.","title":"CMake Interface"},{"location":"cmake/interface/#tolc-cmake-interface","text":"The main interface is through tolc_create_bindings . Example usage: # This function comes from the tolc package itself # Creates the target example_python that can be imported and used from python tolc_create_bindings( # Target to translate from TARGET example # Language to target LANGUAGE python # Where to put the bindings OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python-bindings ) This assumes there is a CMake target called example that has some include directories marked either PUBLIC or INTERFACE . It will look through these directories for header files (any files ending in .h or .hpp ) and export everything inside them to python via pybind11 . It will then create the target example_python that can be used to compile an importable CPython library. The following figure shows the whole process:","title":"Tolc CMake interface"},{"location":"cmake/interface/#complete-example","text":"cmake_minimum_required(VERSION 3.15) project(tolc-demo LANGUAGES CXX) add_library(Math src/Demo/demo.cpp) target_include_directories(Math PUBLIC include) set_target_properties( Math PROPERTIES CXX_STANDARD 17 CXX_STANDARD_REQUIRED ON CXX_EXTENSIONS OFF ) include(FetchContent) FetchContent_Declare( tolc_bootstrap GIT_REPOSITORY https://github.com/Tolc-Software/bootstrap-tolc-cmake GIT_TAG main ) FetchContent_MakeAvailable(tolc_bootstrap) get_tolc() tolc_create_bindings( TARGET Math LANGUAGE python OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python-bindings ) You can find full project examples on the Tolc-Software github page .","title":"Complete example"},{"location":"cmake/reference/","text":"CMake Reference tolc_create_bindings Creates a target that is the library that can be consumed by some other language. The resulting target name is ${TARGET}_${LANGUAGE} (e.g. MyCppLib_python ). Parameters TARGET Specifies the target to be translated. By default it will search the PUBLIC / INTERFACE directories for headers to translate. Will link the created target with this input. LANGUAGE The language to translate to. Will determine the output format of tolc . Will also determine any dependencies to be downloaded (in the case of python , pybind11 will be downloaded locally to the build directory). OUTPUT Determines the output directory for the bindings. HEADERS Takes a list of headers relative the current file. Adds headers to be translated. Useful for adding forward declarated templates or together with DO_NOT_SEARCH_TARGET_INCLUDES to declare which part of the public interface to translate. DO_NOT_SEARCH_TARGET_INCLUDES Disable searching the public interface of TARGET for header files. This can be used in tandem with HEADERS to only translate a specific part of the public interface. NO_ANALYTICS Disable analytics. Example tolc_create_bindings( TARGET MyLib LANGUAGE python HEADERS include/MyLib.hpp include/myForwardDeclarations.hpp DO_NOT_SEARCH_TARGET_INCLUDES OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python-bindings )","title":"Reference"},{"location":"cmake/reference/#cmake-reference","text":"","title":"CMake Reference"},{"location":"cmake/reference/#tolc_create_bindings","text":"Creates a target that is the library that can be consumed by some other language. The resulting target name is ${TARGET}_${LANGUAGE} (e.g. MyCppLib_python ).","title":"tolc_create_bindings"},{"location":"cmake/reference/#parameters","text":"TARGET Specifies the target to be translated. By default it will search the PUBLIC / INTERFACE directories for headers to translate. Will link the created target with this input. LANGUAGE The language to translate to. Will determine the output format of tolc . Will also determine any dependencies to be downloaded (in the case of python , pybind11 will be downloaded locally to the build directory). OUTPUT Determines the output directory for the bindings. HEADERS Takes a list of headers relative the current file. Adds headers to be translated. Useful for adding forward declarated templates or together with DO_NOT_SEARCH_TARGET_INCLUDES to declare which part of the public interface to translate. DO_NOT_SEARCH_TARGET_INCLUDES Disable searching the public interface of TARGET for header files. This can be used in tandem with HEADERS to only translate a specific part of the public interface. NO_ANALYTICS Disable analytics.","title":"Parameters"},{"location":"cmake/reference/#example","text":"tolc_create_bindings( TARGET MyLib LANGUAGE python HEADERS include/MyLib.hpp include/myForwardDeclarations.hpp DO_NOT_SEARCH_TARGET_INCLUDES OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python-bindings )","title":"Example"},{"location":"objc/conversions/","text":"C++ to Objective-C conversions This page shows what is automatically translated and to what. On the left is the C++ and to the right what the corresponding interface in Objective-C will be. Not converted means there will be no automatic translation to a corresponding language object. Note that any restriction this poses only applies to the public interface of your code (e.g. your public headers). Your internal code can use anything from C++. Conversion tables C++ Objective-C translation Namespace Prefix* Nested namespace Prefix* Class Class Public function Class function Private function Not converted Virtual function ??? Operator ??? Static member function Static class function Static member variable Static class variable Public const member variable Readonly property Public non const member variable Readwrite property Private member variable Not converted Global variable Static class property** Global static variable Static class property** Free function Static class function** Overloaded function Class function*** Enum NS_ENUM Scoped enum NS_ENUM Templated class/function Not converted**** Specialized class template Class*** Specialized function template Function*** Documentation Documentation * Prefix on all classes and free functions in the namespace. ** Wrapped in a class with a name that starts with the module name. *** The naming convention for these classes and functions can be found under the Naming Convention page . **** No direct translation to Objective-C. Will not emit warning. C++ operator Objective-C operator operator+ ??? operator- ??? operator* ??? operator/ ??? operator% ??? operator+= ??? operator-= ??? operator*= ??? operator/= ??? operator%= ??? operator== ??? operator!= ??? operator> ??? operator>= ??? operator< ??? operator<= ??? operator[] ??? operator() ??? operator= Not converted operator<< Not converted operator>> Not converted operator++ Not converted operator-- Not converted C++ Standard library class Objective-C translation std::array NSArray std::complex ??? std::deque NSArray std::filesystem::path NSString std::forward_list Not converted std::function ??? std::list NSArray std::map NSDictionary std::multimap Not converted std::multiset Not converted std::optional Value or nil std::pair NSArray std::priority_queue Not converted std::queue Not converted std::set NSOrderedSet std::shared_ptr Value* std::stack Not converted std::string NSString std::string_view NSString std::tuple NSArray std::unique_ptr Value std::unordered_map NSDictionary std::unordered_multimap Not converted std::unordered_multiset Not converted std::unordered_set NSSet std::valarray NSArray std::variant ??? std::vector NSArray * After using a shared_ptr , the object is now always managed by a shared_ptr . C++ builtin type Objective-C translation bool bool char char char16_t char16_t char32_t char32_t double double float float int int int8_t int8_t int16_t int16_t int32_t int32_t int64_t int64_t long double long double long int long int long long int long long int short int short int signed char signed char uint8_t uint8_t uint16_t uint16_t uint32_t uint32_t uint64_t uint64_t unsigned char unsigned char unsigned int unsigned int unsigned long int unsigned long int unsigned long long int unsigned long long int unsigned short int unsigned short int wchar_t wchar_t void void","title":"Conversions"},{"location":"objc/conversions/#c-to-objective-c-conversions","text":"This page shows what is automatically translated and to what. On the left is the C++ and to the right what the corresponding interface in Objective-C will be. Not converted means there will be no automatic translation to a corresponding language object. Note that any restriction this poses only applies to the public interface of your code (e.g. your public headers). Your internal code can use anything from C++.","title":"C++ to Objective-C conversions"},{"location":"objc/conversions/#conversion-tables","text":"C++ Objective-C translation Namespace Prefix* Nested namespace Prefix* Class Class Public function Class function Private function Not converted Virtual function ??? Operator ??? Static member function Static class function Static member variable Static class variable Public const member variable Readonly property Public non const member variable Readwrite property Private member variable Not converted Global variable Static class property** Global static variable Static class property** Free function Static class function** Overloaded function Class function*** Enum NS_ENUM Scoped enum NS_ENUM Templated class/function Not converted**** Specialized class template Class*** Specialized function template Function*** Documentation Documentation * Prefix on all classes and free functions in the namespace. ** Wrapped in a class with a name that starts with the module name. *** The naming convention for these classes and functions can be found under the Naming Convention page . **** No direct translation to Objective-C. Will not emit warning. C++ operator Objective-C operator operator+ ??? operator- ??? operator* ??? operator/ ??? operator% ??? operator+= ??? operator-= ??? operator*= ??? operator/= ??? operator%= ??? operator== ??? operator!= ??? operator> ??? operator>= ??? operator< ??? operator<= ??? operator[] ??? operator() ??? operator= Not converted operator<< Not converted operator>> Not converted operator++ Not converted operator-- Not converted C++ Standard library class Objective-C translation std::array NSArray std::complex ??? std::deque NSArray std::filesystem::path NSString std::forward_list Not converted std::function ??? std::list NSArray std::map NSDictionary std::multimap Not converted std::multiset Not converted std::optional Value or nil std::pair NSArray std::priority_queue Not converted std::queue Not converted std::set NSOrderedSet std::shared_ptr Value* std::stack Not converted std::string NSString std::string_view NSString std::tuple NSArray std::unique_ptr Value std::unordered_map NSDictionary std::unordered_multimap Not converted std::unordered_multiset Not converted std::unordered_set NSSet std::valarray NSArray std::variant ??? std::vector NSArray * After using a shared_ptr , the object is now always managed by a shared_ptr . C++ builtin type Objective-C translation bool bool char char char16_t char16_t char32_t char32_t double double float float int int int8_t int8_t int16_t int16_t int32_t int32_t int64_t int64_t long double long double long int long int long long int long long int short int short int signed char signed char uint8_t uint8_t uint16_t uint16_t uint32_t uint32_t uint64_t uint64_t unsigned char unsigned char unsigned int unsigned int unsigned long int unsigned long int unsigned long long int unsigned long long int unsigned short int unsigned short int wchar_t wchar_t void void","title":"Conversion tables"},{"location":"objc/examples/","text":"Examples Each example is taken from the test suite for Tolc and, given that you use the latest version, you can expect them all to work. Each C++ library named MyLib exports their functions and objects with a prefix of MyLib . In every test the library name is simply m for brevity. The examples that follow contains a bit of C++ code, and the respective Objective-C and Swift code using it. Each Objective-C example is wrapped in the following boilerplate that is removed to make the examples more readable: #include <m.h> int main() { @autoreleasepool { assert([m sayHello] == \"Hello\"); } } And the same for Swift : import m_swift assert(m.sayHello() == \"Hello\") Classes class WithConstructor { public: explicit WithConstructor() : m_v(10) {} explicit WithConstructor(int v) : m_v(v) {} int getV() { return m_v; } private: int m_v; }; class WithFunction { public: int add(int i, int j) { return i + j; } }; class WithStatic { public: static double getPi() { return 3.14; } static int const answer = 42; }; class WithMember { public: explicit WithMember() : i(10), phi(1.618) {} int i; double const phi; }; // Constructors are overloaded with their argument types mWithConstructor* ten = [[mWithConstructor alloc] init]; assert([ten getV] == 10); mWithConstructor* five = [[mWithConstructor alloc] initWithInt:5]; assert([five getV] == 5); // Member functions are available after construction mWithFunction* withFunction = [[mWithFunction alloc] init]; assert([withFunction add: 2 j: 5] == 7); // Static functions can be called // without instantiating the class assert([mWithStatic getPi] == 3.14); // You can access static variables // without instantiating the class assert([mWithStatic answer] == 42); // Member variables mWithMember* member = [[mWithMember alloc] init]; assert(member.i == 10); // i is not marked const member.i = 5; assert(member.i == 5); // phi is marked const // Cannot be assigned assert(member.phi == 1.618); Enums enum Unscoped { Under, Uboat, }; enum class Scoped { Sacred, Snail, }; class EnumTest { public: explicit EnumTest(Scoped _s) : s(_s) {}; Unscoped f(Unscoped u) { return u; } Scoped s; }; namespace NS { // Documentation describing the enum enum class Deep { Double, Down, }; } // C++11 enums work mEnumTest* enumTest = [[mEnumTest alloc] initWithScoped:mScopedSnail]; mScoped snail = mScopedSnail; assert(enumTest.s == snail); // Aswell as legacy enums mUnscoped uboat = mUnscopedUboat; assert([enumTest f:uboat] == uboat); // Enums under namespaces are available // under the corresponding submodule /* deep = m.NS.Deep.Down */ /* assert(deep != m.NS.Deep.Double) */ // Documentation carries over from C++ // self.assertIn(\"Documentation describing the enum\", m.NS.Deep.__doc__) Functions #include <filesystem> #include <string> int meaningOfLife() { return 42; } std::string sayHello(std::string const& name) { return \"Hello \" + name; } std::filesystem::path getPath() { return std::filesystem::path(\"/path/to/stuff.hpp\"); } namespace Inner { double pi() { return 3.14; } } // Global functions gets added to // a purely static class with // the name of the library assert([m meaningOfLife] == 42); // Strings can be used assert([[m sayHello:@\"Tolc\"] isEqualToString:@\"Hello Tolc\"]); // Aswell as filesystem paths assert([[m getPath] isEqualToString:@\"/path/to/stuff.hpp\"]); // Functions within namespaces // are available with the // namespaces names merged assert([mInner pi] == 3.14); Global Variables #include <string> #include <string_view> static int i = 0; namespace Nested { int life = 42; std::string s = \"Hello World\"; constexpr std::string_view constant = \"A constant\"; } // Starts at 0 and can be changed assert(m.i == 0); m.i = 5; assert(m.i == 5); // Nested with the same name assert(mNested.life == 42); // Strings also work assert([mNested.s isEqualToString:@\"Hello World\"]); // And string_view assert([mNested.constant isEqualToString:@\"A constant\"]); Member Variables #include <string> class SimpleMember { public: explicit SimpleMember() : myString(\"Hello\") {} std::string myString; }; class ConstMember { public: const int i = 42; }; class PrivateMember { public: explicit PrivateMember(std::string s) : myString(s) {} private: std::string myString; }; namespace MyLib { class Nested { public: double d = 4.3; }; } // Mutable member variables can be changed mSimpleMember* simpleMember = [[mSimpleMember alloc] init]; assert([simpleMember.myString isEqualToString:@\"Hello\"]); simpleMember.myString = @\"Changed now!\"; assert([simpleMember.myString isEqualToString:@\"Changed now!\"]); mConstMember* constMember = [[mConstMember alloc] init]; assert(constMember.i == 42); mMyLibNested* nested = [[mMyLibNested alloc] init]; assert(nested.d == 4.3); Namespaces #include <string> /* * MyLib contains a bunch of MyLib functions */ namespace MyLib { int complexFunction() { return 5; } namespace We { namespace Are { namespace Going { namespace Pretty { namespace Deep { std::string meaningOfLife() { return \"42\"; } } } } } } } // Namespaces corresponds to classes // with {library name} + join(namespaces) // where functions are static class functions assert([mMyLib complexFunction] == 5); // You can nest namespaces arbitrarily deep NSString* lifeProTips = [mMyLibWeAreGoingPrettyDeep meaningOfLife]; assert([lifeProTips isEqualToString:@\"42\"]); Overloaded Functions #include <string> // Overloaded free functions std::string sayHello() { return \"Hello!\"; } std::string sayHello(std::string to) { return std::string(\"Hello \") + to; } std::string sayHello(size_t times) { std::string greeting = \"\"; for (size_t i = 0; i < times; ++i) { greeting += \"Hello!\"; } return greeting; } class Overload { public: // Overloaded constructor Overload() : m_s() {}; Overload(std::string s) : m_s(s) {}; // Overloaded class functions std::string getStuff() { return \"Stuff\"; } std::string getStuff(std::string customStuff) { return customStuff; } private: std::string m_s; }; // Overloaded functions work the same as in C++ // Free function overload assert([[m sayHello] isEqualToString:@\"Hello!\"]); assert([[m sayHelloString:@\"Tolc\"] isEqualToString:@\"Hello Tolc\"]); assert([[m sayHelloUnsignedLongInt:2] isEqualToString:@\"Hello!Hello!\"]); // Class constructor overload mOverload* overload = [[mOverload alloc] init]; mOverload* overloadWithString = [[mOverload alloc] initWithString:@\"Overloaded!\"]; // Class function overload assert([[overload getStuff] isEqualToString:@\"Stuff\"]); assert([[overload getStuffString:@\"Other\"] isEqualToString:@\"Other\"]); Passing classes between languages #include <string> class MyClass { public: explicit MyClass(std::string s) : m_s(s) {} std::string* getS() { return &m_s; } private: std::string m_s; }; MyClass buildMyClass(std::string const& s) { return MyClass(s); } class Owner { public: explicit Owner(MyClass m) : m_myClass(m) {}; MyClass getMyClass() const { return m_myClass; } private: MyClass m_myClass; }; struct Point2d { int x; int y; }; Point2d getMiddle(std::pair<Point2d, Point2d> p) { return {(p.first.x + p.second.x) / 2, (p.first.y + p.second.y) / 2}; } NSString* phrase = @\"Hello from Objective-C\"; mMyClass* myClass = [m buildMyClass:phrase]; assert([[myClass getS] isEqualToString:phrase]); // Passing Objective-C classes to C++ classes mOwner* owner = [[mOwner alloc] initWithMyClass:myClass]; assert([[[owner getMyClass] getS] isEqualToString:phrase]); // Container of user defined classes mPoint2d* a = [[mPoint2d alloc] init]; a.x = 1; a.y = 0; mPoint2d* b = [[mPoint2d alloc] init]; b.x = 3; b.y = 0; NSArray* points = [NSArray arrayWithObjects:a, b, nil]; mPoint2d* middle = [m getMiddle:points]; assert(middle.x == 2); assert(middle.y == 0); Smart Pointers #include <memory> struct Data { int i = 5; }; struct SharedData { int i = 10; }; std::unique_ptr<Data> createData() { return std::make_unique<Data>(); } // This moves the data, // destroying it at the end // Same as C++ int consumeData(std::unique_ptr<Data> data) { return data->i + 20; } std::shared_ptr<SharedData> createSharedData() { return std::make_shared<SharedData>(); } // Does not move the data // The pointer is valid after the function call int consumeSharedData(std::shared_ptr<SharedData> data) { return data->i + 20; } // std::unique_ptr acts as a normal value mData* data = [m createData]; assert(data.i == 5); // This moves the data, // destroying it at the end // Same as C++ assert([m consumeData:data] == 25); // Any access now results // in undefined behaviour // (possibly a crash) // NSLog(@\"%i\", data.i); // std::shared_ptr acts as a normal value // But all mSharedData have their internal // classes handled by a std::shared_ptr mSharedData* sharedData = [m createSharedData]; assert(sharedData.i == 10); // This copies the smart pointer, // incrementing its counter. // Valid to use sharedData after this call. assert([m consumeSharedData:sharedData] == 30); // No crash NSLog(@\"%i\", sharedData.i); Templates #include <array> #include <map> #include <string> #include <vector> template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string something); template int getSomething(int); template std::vector<std::string> getSomething(std::vector<std::string>); template <typename T> class MyClass { public: T myFun(T type) { return type; } }; MyClass<char> getMyClass(MyClass<char> c) { return c; } template class MyClass<int>; template class MyClass<std::array<int, 3>>; // getSomething<std::string> NSString* hi = [m getSomethingString:@\"Hi\"]; assert([hi isEqualToString:@\"Hi\"]); // getSomething<int> int five = [m getSomethingInt:5]; assert(five == 5); // getSomething<std::vector<std::string>> NSArray* v = [m getSomethingVectorString:@[@\"Hi\"]]; assert([v count] == 1); assert([[v objectAtIndex:0] isEqualToString:@\"Hi\"]); // MyClass<char> mMyClassChar* myClassChar = [[mMyClassChar alloc] init];; assert([myClassChar myFun:25] == 25);; // Still the same after passing through a function mMyClassChar* passedThrough = [m getMyClass:myClassChar];; assert([passedThrough myFun:25] == 25);; // MyClass<int> mMyClassInt* myClassInt = [[mMyClassInt alloc] init]; assert([myClassInt myFun:25] == 25); // MyClass<std::array<int, 3>> mMyClassArrayInt3* myClassArray = [[mMyClassArrayInt3 alloc] init]; NSArray* arr = [myClassArray myFun:@[@(0), @(1), @(2)]]; assert([arr count] == 3); assert([[arr objectAtIndex:0] intValue] == 0); assert([[arr objectAtIndex:1] intValue] == 1); assert([[arr objectAtIndex:2] intValue] == 2); std::array #include <algorithm> #include <array> std::array<int, 3> const f() { return {0, 1, 2}; } bool allOf(std::array<bool, 3> const& conditions) { return std::all_of( conditions.begin(), conditions.end(), [](auto c) { return c; }); } double sum(std::array<double, 3> const& numbers) { double sum = 0; for (double number : numbers) { sum += number; } return sum; } // std::array corresponds to NSArray NSArray* v = [m f]; assert([v count] == 3); // The array contains {0, 1, 2} assert([[v objectAtIndex:0] intValue] == 0); assert([[v objectAtIndex:1] intValue] == 1); assert([[v objectAtIndex:2] intValue] == 2); // Sending NSArray into function works as well NSArray* conditions = @[@(YES), @(YES), @(NO)]; assert([m allOf:conditions] == NO); NSArray<NSNumber*>* toSum = @[@(1.1), @(2.2), @(3.3)]; assert([m sum:toSum] == 6.6); // Error handling @try { // Array with the wrong size NSArray<NSNumber*>* toSum = @[@(1.1), @(2.2)]; // Expected size == 3 [m sum:toSum]; // Should throw exception before assert(NO); } @catch(NSException* error) { assert([[error name] isEqualToString:@\"TypeException\"]); NSString* reason = @\"The size of the array does not match the expected fixed size. Expected: 3, Got: 2.\"; assert([[error reason] isEqualToString:reason]); } std::deque #include <string> #include <deque> std::deque<std::string> surround(std::deque<std::string> d, std::string const& message) { d.push_front(message); d.push_back(message); return d; } // std::deque corresponds to NSArray NSArray* myDeque = @[@\"middle\"]; NSArray* surroundedDeque = [m surround:myDeque message:@\"surrounded\"]; assert([surroundedDeque count] == 3); assert([[surroundedDeque objectAtIndex:0] isEqualToString:@\"surrounded\"]); assert([[surroundedDeque objectAtIndex:1] isEqualToString:@\"middle\"]); assert([[surroundedDeque objectAtIndex:2] isEqualToString:@\"surrounded\"]); std::filesystem::path #include <filesystem> #include <vector> std::filesystem::path takingPath(std::filesystem::path const& p) { return p; } std::filesystem::path parent(std::filesystem::path const& p) { return p.parent_path(); } std::filesystem::path joinPaths(std::vector<std::filesystem::path> arrayToSum) { std::filesystem::path sum; for (auto f : arrayToSum) { sum /= f; } return sum; } // std::filesystem::path corresponds to NSString NSString* path = @\"Hello/my/name/is/Tolc\"; // Passing through a function NSString* result = [m takingPath:path]; assert([result isEqualToString:path]); NSString* parent = [m parent:path]; assert([parent isEqualToString:@\"Hello/my/name/is\"]); NSArray* paths = @[@\"to\", @\"the\", @\"heart\"]; NSString* joined = [m joinPaths:paths]; assert([joined isEqualToString:@\"to/the/heart\"]); std::list #include <string> #include <list> std::list<std::string> getList() { return {\"Linked\", \"list\", \"fun\"}; } // std::list corresponds to NSArray NSArray* words = [m getList]; assert([words count] == 3); assert([[words objectAtIndex:0] isEqualToString:@\"Linked\"]); assert([[words objectAtIndex:1] isEqualToString:@\"list\"]); assert([[words objectAtIndex:2] isEqualToString:@\"fun\"]); std::map #include <map> #include <string> #include <vector> std::map<std::string, int> getThings() { return {{\"Greetings\", 5}}; } std::map<std::string, std::vector<double>> getCities() { return { {\"Stockholm\", {59.33, 18.06}}, {\"San Francisco\", {37.77, -122.43}} }; } // std::map translates to a NSDictionary NSDictionary* dict = [m getThings]; assert([dict count] == 1); NSNumber* n = [dict objectForKey:@\"Greetings\"]; assert(n != nil); assert([n intValue] == 5); // Nested containers work as well NSDictionary* cities = [m getCities]; assert([cities count] == 2); NSArray* stockholm = [cities objectForKey:@\"Stockholm\"]; assert(stockholm != nil); assert([stockholm count] == 2); assert([[stockholm objectAtIndex:0] doubleValue] == 59.33); assert([[stockholm objectAtIndex:1] doubleValue] == 18.06); NSArray* sanFrancisco = [cities objectForKey:@\"San Francisco\"]; assert(sanFrancisco != nil); assert([sanFrancisco count] == 2); assert([[sanFrancisco objectAtIndex:0] doubleValue] == 37.77); assert([[sanFrancisco objectAtIndex:1] doubleValue] == -122.43); std::optional #include <optional> #include <string> std::string answer(std::optional<std::string> const& question) { if (question) { return \"Please be more specific.\"; } return \"That's no question!\"; } // std::optional is either the value or nil NSString* answer = [m answer:@\"How do I take over the world?\"]; assert([answer isEqualToString:@\"Please be more specific.\"]); // nil is the equivalent of std::nullopt on the C++ side NSString* noAnswer = [m answer:nil]; assert([noAnswer isEqualToString:@\"That's no question!\"]); std::pair #include <string> class Greeter { public: explicit Greeter(std::pair<std::string, int> greetings) : m_greetings(greetings) {} std::pair<std::string, int> getGreetings() { return m_greetings; } std::string joinGreetings() { std::string joined; for (int i = 0; i < m_greetings.second; ++i) { joined += m_greetings.first; } return joined; } private: std::pair<std::string, int> m_greetings; }; // std::pair corresponds to a NSArray // with two values NSArray* greetings = [NSArray arrayWithObjects:@\"Hey \", @(3), nil]; assert([greetings count] == 2); // Sending a pair to a function mGreeter* g = [[mGreeter alloc] initWithPairStringInt:greetings]; // Joining the greetings 3 times NSString* joined = [g joinGreetings]; assert([joined isEqualToString:@\"Hey Hey Hey \"]); // Error handling @try { // Sending an array with size != 2 NSArray* tooManyArgs = [greetings arrayByAddingObject:@\"Oh no\"]; mGreeter* boom = [[mGreeter alloc] initWithPairStringInt:tooManyArgs]; // Should throw exception before assert(NO); } @catch(NSException* error) { assert([[error name] isEqualToString:@\"TypeException\"]); NSString* reason = @\"The array passed does not match the number of types in a pair. Expected: 2, Got: 3.\"; assert([[error reason] isEqualToString:reason]); } std::set #include <set> #include <string> std::set<std::string> getLanguages() { return {\"English\", \"Spanish\"}; } // std::set corresponds to NSOrderedSet NSOrderedSet* languages = [m getLanguages]; assert([languages count] == 2); assert([languages containsObject:@\"English\"]); assert([languages containsObject:@\"Spanish\"]); std::tuple #include <string> #include <tuple> std::tuple<int, std::string> sumInts(std::tuple<int, int, std::string> t) { // Sum the first two elements return { std::get<0>(t) + std::get<1>(t), std::get<2>(t) }; } // std::tuple corresponds to a NSArray // with the same amount of values NSArray* toSum = [NSArray arrayWithObjects:@(1), @(2), @\"Hello\", nil]; assert([toSum count] == 3); // Sending a tuple to a function NSArray* summed = [m sumInts:toSum]; assert([summed count] == 2); assert([[summed objectAtIndex:0] intValue] == 3); assert([[summed objectAtIndex:1] isEqualToString:@\"Hello\"]); // Error handling @try { // Sending an array with size != 3 NSArray* tooManyArgs = [toSum arrayByAddingObject:@\"Boom\"]; [m sumInts:tooManyArgs]; // Should throw exception before assert(NO); } @catch(NSException* error) { assert([[error name] isEqualToString:@\"TypeException\"]); NSString* reason = @\"The array passed does not match the number of types expected in the tuple. Expected: 3, Got: 4.\"; assert([[error reason] isEqualToString:reason]); } std::unordered_map #include <string> #include <unordered_map> std::unordered_map<std::string, int> getUnordered() { return {{\"Unordered\", 1}}; } // std::unordered_map translates to a NSDictionary NSDictionary* dict = [m getUnordered]; assert([dict count] == 1); NSNumber* n = [dict objectForKey:@\"Unordered\"]; assert(n != nil); assert([n intValue] == 1); std::unordered_set #include <string> #include <unordered_set> std::unordered_set<std::string> getLanguages() { return {\"C++\", \"Objective-C\"}; } // std::unordered_set corresponds to NSSet NSSet* languages = [m getLanguages]; assert([languages count] == 2); assert([languages containsObject:@\"C++\"]); assert([languages containsObject:@\"Objective-C\"]); std::valarray #include <valarray> std::valarray<int> getIt() { return {0, 1, 2}; } // std::valarray corresponds to NSArray NSArray* v = [m getIt]; assert([v count] == 3); // The vector contains {0, 1, 2} assert([[v objectAtIndex:0] intValue] == 0); assert([[v objectAtIndex:1] intValue] == 1); assert([[v objectAtIndex:2] intValue] == 2); std::vector #include <algorithm> #include <vector> std::vector<int> f() { return {0, 1, 2}; } bool allOf(std::vector<bool> const& conditions) { return std::all_of( conditions.begin(), conditions.end(), [](auto c) { return c; }); } double sum(std::vector<double> const& numbers) { double sum = 0; for (double number : numbers) { sum += number; } return sum; } // std::vector corresponds to NSArray NSArray* v = [m f]; assert([v count] == 3); // The vector contains {0, 1, 2} assert([[v objectAtIndex:0] intValue] == 0); assert([[v objectAtIndex:1] intValue] == 1); assert([[v objectAtIndex:2] intValue] == 2); // Sending NSArray into function works as well NSArray* conditions = @[@(YES), @(YES), @(NO)]; assert([m allOf:conditions] == NO); NSArray<NSNumber*>* toSum = @[@(1.1), @(2.2), @(3.3)]; assert([m sum:toSum] == 6.6);","title":"Examples"},{"location":"objc/examples/#examples","text":"Each example is taken from the test suite for Tolc and, given that you use the latest version, you can expect them all to work. Each C++ library named MyLib exports their functions and objects with a prefix of MyLib . In every test the library name is simply m for brevity. The examples that follow contains a bit of C++ code, and the respective Objective-C and Swift code using it. Each Objective-C example is wrapped in the following boilerplate that is removed to make the examples more readable: #include <m.h> int main() { @autoreleasepool { assert([m sayHello] == \"Hello\"); } } And the same for Swift : import m_swift assert(m.sayHello() == \"Hello\")","title":"Examples"},{"location":"objc/examples/#classes","text":"class WithConstructor { public: explicit WithConstructor() : m_v(10) {} explicit WithConstructor(int v) : m_v(v) {} int getV() { return m_v; } private: int m_v; }; class WithFunction { public: int add(int i, int j) { return i + j; } }; class WithStatic { public: static double getPi() { return 3.14; } static int const answer = 42; }; class WithMember { public: explicit WithMember() : i(10), phi(1.618) {} int i; double const phi; }; // Constructors are overloaded with their argument types mWithConstructor* ten = [[mWithConstructor alloc] init]; assert([ten getV] == 10); mWithConstructor* five = [[mWithConstructor alloc] initWithInt:5]; assert([five getV] == 5); // Member functions are available after construction mWithFunction* withFunction = [[mWithFunction alloc] init]; assert([withFunction add: 2 j: 5] == 7); // Static functions can be called // without instantiating the class assert([mWithStatic getPi] == 3.14); // You can access static variables // without instantiating the class assert([mWithStatic answer] == 42); // Member variables mWithMember* member = [[mWithMember alloc] init]; assert(member.i == 10); // i is not marked const member.i = 5; assert(member.i == 5); // phi is marked const // Cannot be assigned assert(member.phi == 1.618);","title":"Classes"},{"location":"objc/examples/#enums","text":"enum Unscoped { Under, Uboat, }; enum class Scoped { Sacred, Snail, }; class EnumTest { public: explicit EnumTest(Scoped _s) : s(_s) {}; Unscoped f(Unscoped u) { return u; } Scoped s; }; namespace NS { // Documentation describing the enum enum class Deep { Double, Down, }; } // C++11 enums work mEnumTest* enumTest = [[mEnumTest alloc] initWithScoped:mScopedSnail]; mScoped snail = mScopedSnail; assert(enumTest.s == snail); // Aswell as legacy enums mUnscoped uboat = mUnscopedUboat; assert([enumTest f:uboat] == uboat); // Enums under namespaces are available // under the corresponding submodule /* deep = m.NS.Deep.Down */ /* assert(deep != m.NS.Deep.Double) */ // Documentation carries over from C++ // self.assertIn(\"Documentation describing the enum\", m.NS.Deep.__doc__)","title":"Enums"},{"location":"objc/examples/#functions","text":"#include <filesystem> #include <string> int meaningOfLife() { return 42; } std::string sayHello(std::string const& name) { return \"Hello \" + name; } std::filesystem::path getPath() { return std::filesystem::path(\"/path/to/stuff.hpp\"); } namespace Inner { double pi() { return 3.14; } } // Global functions gets added to // a purely static class with // the name of the library assert([m meaningOfLife] == 42); // Strings can be used assert([[m sayHello:@\"Tolc\"] isEqualToString:@\"Hello Tolc\"]); // Aswell as filesystem paths assert([[m getPath] isEqualToString:@\"/path/to/stuff.hpp\"]); // Functions within namespaces // are available with the // namespaces names merged assert([mInner pi] == 3.14);","title":"Functions"},{"location":"objc/examples/#global-variables","text":"#include <string> #include <string_view> static int i = 0; namespace Nested { int life = 42; std::string s = \"Hello World\"; constexpr std::string_view constant = \"A constant\"; } // Starts at 0 and can be changed assert(m.i == 0); m.i = 5; assert(m.i == 5); // Nested with the same name assert(mNested.life == 42); // Strings also work assert([mNested.s isEqualToString:@\"Hello World\"]); // And string_view assert([mNested.constant isEqualToString:@\"A constant\"]);","title":"Global Variables"},{"location":"objc/examples/#member-variables","text":"#include <string> class SimpleMember { public: explicit SimpleMember() : myString(\"Hello\") {} std::string myString; }; class ConstMember { public: const int i = 42; }; class PrivateMember { public: explicit PrivateMember(std::string s) : myString(s) {} private: std::string myString; }; namespace MyLib { class Nested { public: double d = 4.3; }; } // Mutable member variables can be changed mSimpleMember* simpleMember = [[mSimpleMember alloc] init]; assert([simpleMember.myString isEqualToString:@\"Hello\"]); simpleMember.myString = @\"Changed now!\"; assert([simpleMember.myString isEqualToString:@\"Changed now!\"]); mConstMember* constMember = [[mConstMember alloc] init]; assert(constMember.i == 42); mMyLibNested* nested = [[mMyLibNested alloc] init]; assert(nested.d == 4.3);","title":"Member Variables"},{"location":"objc/examples/#namespaces","text":"#include <string> /* * MyLib contains a bunch of MyLib functions */ namespace MyLib { int complexFunction() { return 5; } namespace We { namespace Are { namespace Going { namespace Pretty { namespace Deep { std::string meaningOfLife() { return \"42\"; } } } } } } } // Namespaces corresponds to classes // with {library name} + join(namespaces) // where functions are static class functions assert([mMyLib complexFunction] == 5); // You can nest namespaces arbitrarily deep NSString* lifeProTips = [mMyLibWeAreGoingPrettyDeep meaningOfLife]; assert([lifeProTips isEqualToString:@\"42\"]);","title":"Namespaces"},{"location":"objc/examples/#overloaded-functions","text":"#include <string> // Overloaded free functions std::string sayHello() { return \"Hello!\"; } std::string sayHello(std::string to) { return std::string(\"Hello \") + to; } std::string sayHello(size_t times) { std::string greeting = \"\"; for (size_t i = 0; i < times; ++i) { greeting += \"Hello!\"; } return greeting; } class Overload { public: // Overloaded constructor Overload() : m_s() {}; Overload(std::string s) : m_s(s) {}; // Overloaded class functions std::string getStuff() { return \"Stuff\"; } std::string getStuff(std::string customStuff) { return customStuff; } private: std::string m_s; }; // Overloaded functions work the same as in C++ // Free function overload assert([[m sayHello] isEqualToString:@\"Hello!\"]); assert([[m sayHelloString:@\"Tolc\"] isEqualToString:@\"Hello Tolc\"]); assert([[m sayHelloUnsignedLongInt:2] isEqualToString:@\"Hello!Hello!\"]); // Class constructor overload mOverload* overload = [[mOverload alloc] init]; mOverload* overloadWithString = [[mOverload alloc] initWithString:@\"Overloaded!\"]; // Class function overload assert([[overload getStuff] isEqualToString:@\"Stuff\"]); assert([[overload getStuffString:@\"Other\"] isEqualToString:@\"Other\"]);","title":"Overloaded Functions"},{"location":"objc/examples/#passing-classes-between-languages","text":"#include <string> class MyClass { public: explicit MyClass(std::string s) : m_s(s) {} std::string* getS() { return &m_s; } private: std::string m_s; }; MyClass buildMyClass(std::string const& s) { return MyClass(s); } class Owner { public: explicit Owner(MyClass m) : m_myClass(m) {}; MyClass getMyClass() const { return m_myClass; } private: MyClass m_myClass; }; struct Point2d { int x; int y; }; Point2d getMiddle(std::pair<Point2d, Point2d> p) { return {(p.first.x + p.second.x) / 2, (p.first.y + p.second.y) / 2}; } NSString* phrase = @\"Hello from Objective-C\"; mMyClass* myClass = [m buildMyClass:phrase]; assert([[myClass getS] isEqualToString:phrase]); // Passing Objective-C classes to C++ classes mOwner* owner = [[mOwner alloc] initWithMyClass:myClass]; assert([[[owner getMyClass] getS] isEqualToString:phrase]); // Container of user defined classes mPoint2d* a = [[mPoint2d alloc] init]; a.x = 1; a.y = 0; mPoint2d* b = [[mPoint2d alloc] init]; b.x = 3; b.y = 0; NSArray* points = [NSArray arrayWithObjects:a, b, nil]; mPoint2d* middle = [m getMiddle:points]; assert(middle.x == 2); assert(middle.y == 0);","title":"Passing classes between languages"},{"location":"objc/examples/#smart-pointers","text":"#include <memory> struct Data { int i = 5; }; struct SharedData { int i = 10; }; std::unique_ptr<Data> createData() { return std::make_unique<Data>(); } // This moves the data, // destroying it at the end // Same as C++ int consumeData(std::unique_ptr<Data> data) { return data->i + 20; } std::shared_ptr<SharedData> createSharedData() { return std::make_shared<SharedData>(); } // Does not move the data // The pointer is valid after the function call int consumeSharedData(std::shared_ptr<SharedData> data) { return data->i + 20; } // std::unique_ptr acts as a normal value mData* data = [m createData]; assert(data.i == 5); // This moves the data, // destroying it at the end // Same as C++ assert([m consumeData:data] == 25); // Any access now results // in undefined behaviour // (possibly a crash) // NSLog(@\"%i\", data.i); // std::shared_ptr acts as a normal value // But all mSharedData have their internal // classes handled by a std::shared_ptr mSharedData* sharedData = [m createSharedData]; assert(sharedData.i == 10); // This copies the smart pointer, // incrementing its counter. // Valid to use sharedData after this call. assert([m consumeSharedData:sharedData] == 30); // No crash NSLog(@\"%i\", sharedData.i);","title":"Smart Pointers"},{"location":"objc/examples/#templates","text":"#include <array> #include <map> #include <string> #include <vector> template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string something); template int getSomething(int); template std::vector<std::string> getSomething(std::vector<std::string>); template <typename T> class MyClass { public: T myFun(T type) { return type; } }; MyClass<char> getMyClass(MyClass<char> c) { return c; } template class MyClass<int>; template class MyClass<std::array<int, 3>>; // getSomething<std::string> NSString* hi = [m getSomethingString:@\"Hi\"]; assert([hi isEqualToString:@\"Hi\"]); // getSomething<int> int five = [m getSomethingInt:5]; assert(five == 5); // getSomething<std::vector<std::string>> NSArray* v = [m getSomethingVectorString:@[@\"Hi\"]]; assert([v count] == 1); assert([[v objectAtIndex:0] isEqualToString:@\"Hi\"]); // MyClass<char> mMyClassChar* myClassChar = [[mMyClassChar alloc] init];; assert([myClassChar myFun:25] == 25);; // Still the same after passing through a function mMyClassChar* passedThrough = [m getMyClass:myClassChar];; assert([passedThrough myFun:25] == 25);; // MyClass<int> mMyClassInt* myClassInt = [[mMyClassInt alloc] init]; assert([myClassInt myFun:25] == 25); // MyClass<std::array<int, 3>> mMyClassArrayInt3* myClassArray = [[mMyClassArrayInt3 alloc] init]; NSArray* arr = [myClassArray myFun:@[@(0), @(1), @(2)]]; assert([arr count] == 3); assert([[arr objectAtIndex:0] intValue] == 0); assert([[arr objectAtIndex:1] intValue] == 1); assert([[arr objectAtIndex:2] intValue] == 2);","title":"Templates"},{"location":"objc/examples/#stdarray","text":"#include <algorithm> #include <array> std::array<int, 3> const f() { return {0, 1, 2}; } bool allOf(std::array<bool, 3> const& conditions) { return std::all_of( conditions.begin(), conditions.end(), [](auto c) { return c; }); } double sum(std::array<double, 3> const& numbers) { double sum = 0; for (double number : numbers) { sum += number; } return sum; } // std::array corresponds to NSArray NSArray* v = [m f]; assert([v count] == 3); // The array contains {0, 1, 2} assert([[v objectAtIndex:0] intValue] == 0); assert([[v objectAtIndex:1] intValue] == 1); assert([[v objectAtIndex:2] intValue] == 2); // Sending NSArray into function works as well NSArray* conditions = @[@(YES), @(YES), @(NO)]; assert([m allOf:conditions] == NO); NSArray<NSNumber*>* toSum = @[@(1.1), @(2.2), @(3.3)]; assert([m sum:toSum] == 6.6); // Error handling @try { // Array with the wrong size NSArray<NSNumber*>* toSum = @[@(1.1), @(2.2)]; // Expected size == 3 [m sum:toSum]; // Should throw exception before assert(NO); } @catch(NSException* error) { assert([[error name] isEqualToString:@\"TypeException\"]); NSString* reason = @\"The size of the array does not match the expected fixed size. Expected: 3, Got: 2.\"; assert([[error reason] isEqualToString:reason]); }","title":"std::array"},{"location":"objc/examples/#stddeque","text":"#include <string> #include <deque> std::deque<std::string> surround(std::deque<std::string> d, std::string const& message) { d.push_front(message); d.push_back(message); return d; } // std::deque corresponds to NSArray NSArray* myDeque = @[@\"middle\"]; NSArray* surroundedDeque = [m surround:myDeque message:@\"surrounded\"]; assert([surroundedDeque count] == 3); assert([[surroundedDeque objectAtIndex:0] isEqualToString:@\"surrounded\"]); assert([[surroundedDeque objectAtIndex:1] isEqualToString:@\"middle\"]); assert([[surroundedDeque objectAtIndex:2] isEqualToString:@\"surrounded\"]);","title":"std::deque"},{"location":"objc/examples/#stdfilesystempath","text":"#include <filesystem> #include <vector> std::filesystem::path takingPath(std::filesystem::path const& p) { return p; } std::filesystem::path parent(std::filesystem::path const& p) { return p.parent_path(); } std::filesystem::path joinPaths(std::vector<std::filesystem::path> arrayToSum) { std::filesystem::path sum; for (auto f : arrayToSum) { sum /= f; } return sum; } // std::filesystem::path corresponds to NSString NSString* path = @\"Hello/my/name/is/Tolc\"; // Passing through a function NSString* result = [m takingPath:path]; assert([result isEqualToString:path]); NSString* parent = [m parent:path]; assert([parent isEqualToString:@\"Hello/my/name/is\"]); NSArray* paths = @[@\"to\", @\"the\", @\"heart\"]; NSString* joined = [m joinPaths:paths]; assert([joined isEqualToString:@\"to/the/heart\"]);","title":"std::filesystem::path"},{"location":"objc/examples/#stdlist","text":"#include <string> #include <list> std::list<std::string> getList() { return {\"Linked\", \"list\", \"fun\"}; } // std::list corresponds to NSArray NSArray* words = [m getList]; assert([words count] == 3); assert([[words objectAtIndex:0] isEqualToString:@\"Linked\"]); assert([[words objectAtIndex:1] isEqualToString:@\"list\"]); assert([[words objectAtIndex:2] isEqualToString:@\"fun\"]);","title":"std::list"},{"location":"objc/examples/#stdmap","text":"#include <map> #include <string> #include <vector> std::map<std::string, int> getThings() { return {{\"Greetings\", 5}}; } std::map<std::string, std::vector<double>> getCities() { return { {\"Stockholm\", {59.33, 18.06}}, {\"San Francisco\", {37.77, -122.43}} }; } // std::map translates to a NSDictionary NSDictionary* dict = [m getThings]; assert([dict count] == 1); NSNumber* n = [dict objectForKey:@\"Greetings\"]; assert(n != nil); assert([n intValue] == 5); // Nested containers work as well NSDictionary* cities = [m getCities]; assert([cities count] == 2); NSArray* stockholm = [cities objectForKey:@\"Stockholm\"]; assert(stockholm != nil); assert([stockholm count] == 2); assert([[stockholm objectAtIndex:0] doubleValue] == 59.33); assert([[stockholm objectAtIndex:1] doubleValue] == 18.06); NSArray* sanFrancisco = [cities objectForKey:@\"San Francisco\"]; assert(sanFrancisco != nil); assert([sanFrancisco count] == 2); assert([[sanFrancisco objectAtIndex:0] doubleValue] == 37.77); assert([[sanFrancisco objectAtIndex:1] doubleValue] == -122.43);","title":"std::map"},{"location":"objc/examples/#stdoptional","text":"#include <optional> #include <string> std::string answer(std::optional<std::string> const& question) { if (question) { return \"Please be more specific.\"; } return \"That's no question!\"; } // std::optional is either the value or nil NSString* answer = [m answer:@\"How do I take over the world?\"]; assert([answer isEqualToString:@\"Please be more specific.\"]); // nil is the equivalent of std::nullopt on the C++ side NSString* noAnswer = [m answer:nil]; assert([noAnswer isEqualToString:@\"That's no question!\"]);","title":"std::optional"},{"location":"objc/examples/#stdpair","text":"#include <string> class Greeter { public: explicit Greeter(std::pair<std::string, int> greetings) : m_greetings(greetings) {} std::pair<std::string, int> getGreetings() { return m_greetings; } std::string joinGreetings() { std::string joined; for (int i = 0; i < m_greetings.second; ++i) { joined += m_greetings.first; } return joined; } private: std::pair<std::string, int> m_greetings; }; // std::pair corresponds to a NSArray // with two values NSArray* greetings = [NSArray arrayWithObjects:@\"Hey \", @(3), nil]; assert([greetings count] == 2); // Sending a pair to a function mGreeter* g = [[mGreeter alloc] initWithPairStringInt:greetings]; // Joining the greetings 3 times NSString* joined = [g joinGreetings]; assert([joined isEqualToString:@\"Hey Hey Hey \"]); // Error handling @try { // Sending an array with size != 2 NSArray* tooManyArgs = [greetings arrayByAddingObject:@\"Oh no\"]; mGreeter* boom = [[mGreeter alloc] initWithPairStringInt:tooManyArgs]; // Should throw exception before assert(NO); } @catch(NSException* error) { assert([[error name] isEqualToString:@\"TypeException\"]); NSString* reason = @\"The array passed does not match the number of types in a pair. Expected: 2, Got: 3.\"; assert([[error reason] isEqualToString:reason]); }","title":"std::pair"},{"location":"objc/examples/#stdset","text":"#include <set> #include <string> std::set<std::string> getLanguages() { return {\"English\", \"Spanish\"}; } // std::set corresponds to NSOrderedSet NSOrderedSet* languages = [m getLanguages]; assert([languages count] == 2); assert([languages containsObject:@\"English\"]); assert([languages containsObject:@\"Spanish\"]);","title":"std::set"},{"location":"objc/examples/#stdtuple","text":"#include <string> #include <tuple> std::tuple<int, std::string> sumInts(std::tuple<int, int, std::string> t) { // Sum the first two elements return { std::get<0>(t) + std::get<1>(t), std::get<2>(t) }; } // std::tuple corresponds to a NSArray // with the same amount of values NSArray* toSum = [NSArray arrayWithObjects:@(1), @(2), @\"Hello\", nil]; assert([toSum count] == 3); // Sending a tuple to a function NSArray* summed = [m sumInts:toSum]; assert([summed count] == 2); assert([[summed objectAtIndex:0] intValue] == 3); assert([[summed objectAtIndex:1] isEqualToString:@\"Hello\"]); // Error handling @try { // Sending an array with size != 3 NSArray* tooManyArgs = [toSum arrayByAddingObject:@\"Boom\"]; [m sumInts:tooManyArgs]; // Should throw exception before assert(NO); } @catch(NSException* error) { assert([[error name] isEqualToString:@\"TypeException\"]); NSString* reason = @\"The array passed does not match the number of types expected in the tuple. Expected: 3, Got: 4.\"; assert([[error reason] isEqualToString:reason]); }","title":"std::tuple"},{"location":"objc/examples/#stdunordered_map","text":"#include <string> #include <unordered_map> std::unordered_map<std::string, int> getUnordered() { return {{\"Unordered\", 1}}; } // std::unordered_map translates to a NSDictionary NSDictionary* dict = [m getUnordered]; assert([dict count] == 1); NSNumber* n = [dict objectForKey:@\"Unordered\"]; assert(n != nil); assert([n intValue] == 1);","title":"std::unordered_map"},{"location":"objc/examples/#stdunordered_set","text":"#include <string> #include <unordered_set> std::unordered_set<std::string> getLanguages() { return {\"C++\", \"Objective-C\"}; } // std::unordered_set corresponds to NSSet NSSet* languages = [m getLanguages]; assert([languages count] == 2); assert([languages containsObject:@\"C++\"]); assert([languages containsObject:@\"Objective-C\"]);","title":"std::unordered_set"},{"location":"objc/examples/#stdvalarray","text":"#include <valarray> std::valarray<int> getIt() { return {0, 1, 2}; } // std::valarray corresponds to NSArray NSArray* v = [m getIt]; assert([v count] == 3); // The vector contains {0, 1, 2} assert([[v objectAtIndex:0] intValue] == 0); assert([[v objectAtIndex:1] intValue] == 1); assert([[v objectAtIndex:2] intValue] == 2);","title":"std::valarray"},{"location":"objc/examples/#stdvector","text":"#include <algorithm> #include <vector> std::vector<int> f() { return {0, 1, 2}; } bool allOf(std::vector<bool> const& conditions) { return std::all_of( conditions.begin(), conditions.end(), [](auto c) { return c; }); } double sum(std::vector<double> const& numbers) { double sum = 0; for (double number : numbers) { sum += number; } return sum; } // std::vector corresponds to NSArray NSArray* v = [m f]; assert([v count] == 3); // The vector contains {0, 1, 2} assert([[v objectAtIndex:0] intValue] == 0); assert([[v objectAtIndex:1] intValue] == 1); assert([[v objectAtIndex:2] intValue] == 2); // Sending NSArray into function works as well NSArray* conditions = @[@(YES), @(YES), @(NO)]; assert([m allOf:conditions] == NO); NSArray<NSNumber*>* toSum = @[@(1.1), @(2.2), @(3.3)]; assert([m sum:toSum] == 6.6);","title":"std::vector"},{"location":"objc/naming_convention/","text":"Naming Convention Signatures which depend on a type Objective-C does not have support for type dependent signatures so relies on each function and type signature to be unique. When Tolc encounters such a signature, it simply concatenates the related type into a Type String . Lets clear that up with some examples: Overloaded Functions The following C++ : string sayHello() { return \"Hi!\"; } string sayHello(string to) { return \"Hi \" + to; } Can be called from Objective-C as: // Results in \"Hi!\" [MyLib sayHello]; // Results in \"Hi Tolc\" [MyLib sayHelloString:@\"Tolc\"]; Templated functions The following C++ : template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string something); Can be called from Objective-C as: NSString* hi = [m getSomethingString:@\"Hi\"]; assert([hi isEqualToString:@\"Hi\"]); Templated classes The following C++ : template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string something); Can be called from Objective-C as: NSString* hi = [m getSomethingString:@\"Hi\"]; assert([hi isEqualToString:@\"Hi\"]); Type String Type String s are used to make C++ signatures unique on the Objective-C side. The names are meant to be as predictable as possible. The rules are: std:: is removed from any standard library type. User defined types are left untouched (i.e. the class MyNamespace::MyClass will result in appending MyClass ). C++ type Resulting name std::array Array std::complex Complex std::deque Deque std::filesystem::path Path std::forward_list Forwardlist std::function Function std::list List std::map Map std::multimap MultiMap std::multiset MultiSet std::optional Optional std::pair Pair std::priority_queue PriorityQueue std::queue Queue std::set Set std::shared_ptr SharedPtr std::stack Stack std::tuple Tuple std::unique_ptr Uniqueptr std::unordered_map UnorderedMap std::unordered_multimap UnorderedMultiMap std::unordered_multiset UnorderedMultiSet std::unordered_set Unorderedset std::valarray Valarray std::variant Variant std::vector Vector bool Bool char Char char16_t Char16t char32_t Char32t double Double float Float int Int Integral Integral literal* long double LongDouble long int LongInt long long int LongLongInt short int ShortInt signed char SignedChar string String string_view StringView unsigned char UnsignedChar unsigned int UnsignedInt unsigned long int UnsignedLongInt unsigned long long int UnsignedLongLongInt unsigned short int UnsignedShortInt wchar_t Wchart * For example the 3 in MyClass<std::array<int, 3>> results in MyClassArrayInt3 .","title":"Naming Convention"},{"location":"objc/naming_convention/#naming-convention","text":"","title":"Naming Convention"},{"location":"objc/naming_convention/#signatures-which-depend-on-a-type","text":"Objective-C does not have support for type dependent signatures so relies on each function and type signature to be unique. When Tolc encounters such a signature, it simply concatenates the related type into a Type String . Lets clear that up with some examples:","title":"Signatures which depend on a type"},{"location":"objc/naming_convention/#overloaded-functions","text":"The following C++ : string sayHello() { return \"Hi!\"; } string sayHello(string to) { return \"Hi \" + to; } Can be called from Objective-C as: // Results in \"Hi!\" [MyLib sayHello]; // Results in \"Hi Tolc\" [MyLib sayHelloString:@\"Tolc\"];","title":"Overloaded Functions"},{"location":"objc/naming_convention/#templated-functions","text":"The following C++ : template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string something); Can be called from Objective-C as: NSString* hi = [m getSomethingString:@\"Hi\"]; assert([hi isEqualToString:@\"Hi\"]);","title":"Templated functions"},{"location":"objc/naming_convention/#templated-classes","text":"The following C++ : template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string something); Can be called from Objective-C as: NSString* hi = [m getSomethingString:@\"Hi\"]; assert([hi isEqualToString:@\"Hi\"]);","title":"Templated classes"},{"location":"objc/naming_convention/#type-string","text":"Type String s are used to make C++ signatures unique on the Objective-C side. The names are meant to be as predictable as possible. The rules are: std:: is removed from any standard library type. User defined types are left untouched (i.e. the class MyNamespace::MyClass will result in appending MyClass ). C++ type Resulting name std::array Array std::complex Complex std::deque Deque std::filesystem::path Path std::forward_list Forwardlist std::function Function std::list List std::map Map std::multimap MultiMap std::multiset MultiSet std::optional Optional std::pair Pair std::priority_queue PriorityQueue std::queue Queue std::set Set std::shared_ptr SharedPtr std::stack Stack std::tuple Tuple std::unique_ptr Uniqueptr std::unordered_map UnorderedMap std::unordered_multimap UnorderedMultiMap std::unordered_multiset UnorderedMultiSet std::unordered_set Unorderedset std::valarray Valarray std::variant Variant std::vector Vector bool Bool char Char char16_t Char16t char32_t Char32t double Double float Float int Int Integral Integral literal* long double LongDouble long int LongInt long long int LongLongInt short int ShortInt signed char SignedChar string String string_view StringView unsigned char UnsignedChar unsigned int UnsignedInt unsigned long int UnsignedLongInt unsigned long long int UnsignedLongLongInt unsigned short int UnsignedShortInt wchar_t Wchart * For example the 3 in MyClass<std::array<int, 3>> results in MyClassArrayInt3 .","title":"Type String"},{"location":"objc/quickstart/","text":"Objective-C with Tolc In order for C++ to be called from Objective-C there has to be an interface level. Tolc generates this level from your already written C++ interface. This is then generated to the appropriate targets by the CMake plugin. Requirements MacOS (uses Foundation headers) Using a C++ library from Objective-C This is a quick guide to using a C++ library (here called MyLib ) from Objective-C . We will: Download Tolc Use Tolc to generate bindings to an existing library Use the C++ library from both Objective-C The following works on all supported platforms. On all platforms you need git available in your path . Commands that should be run from a terminal starts with $ , while comments starts with # . Downloading and using Tolc Just add the following in a CMakeLists.txt below where the library you intend to use is defined: # Download Tolc # Can be [latest, v0.7.0, ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) tolc_create_bindings( TARGET MyLib LANGUAGE objc OUTPUT objc-bindings ) Assuming your library is called MyLib , and the bindings should be generated to the directory objc-bindings . This will also create a build target as MyLib_objc that you can treat as any other target. Now you can configure your project as normal (in Visual Studio, this is typically done automatically on save): $ cmake -S. -Bbuild And finally build it: $ cmake --build build This will produce an Objective-C library under build/tolc (with MSVC it will be under for example build/tolc/Debug ). In order to use it we create an Objective-C application and link it to our libraries: add_executable(Objecty objc/main.m) target_link_libraries(Objecty PRIVATE MyLib_objc) The Tolc CMake plugin has created targets that take care of the rest. From Objective-C : #import <Mylib.h> int main() { MyLibMyCppClass* myCppClass = [[MyLibMyCppClass alloc] init]; [myCppClass someMethod]; } If you want to see what more is supported you can take a look at the Examples section .","title":"Quickstart"},{"location":"objc/quickstart/#objective-c-with-tolc","text":"In order for C++ to be called from Objective-C there has to be an interface level. Tolc generates this level from your already written C++ interface. This is then generated to the appropriate targets by the CMake plugin.","title":"Objective-C with Tolc"},{"location":"objc/quickstart/#requirements","text":"MacOS (uses Foundation headers)","title":"Requirements"},{"location":"objc/quickstart/#using-a-c-library-from-objective-c","text":"This is a quick guide to using a C++ library (here called MyLib ) from Objective-C . We will: Download Tolc Use Tolc to generate bindings to an existing library Use the C++ library from both Objective-C The following works on all supported platforms. On all platforms you need git available in your path . Commands that should be run from a terminal starts with $ , while comments starts with # .","title":"Using a C++ library from Objective-C"},{"location":"objc/quickstart/#downloading-and-using-tolc","text":"Just add the following in a CMakeLists.txt below where the library you intend to use is defined: # Download Tolc # Can be [latest, v0.7.0, ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) tolc_create_bindings( TARGET MyLib LANGUAGE objc OUTPUT objc-bindings ) Assuming your library is called MyLib , and the bindings should be generated to the directory objc-bindings . This will also create a build target as MyLib_objc that you can treat as any other target. Now you can configure your project as normal (in Visual Studio, this is typically done automatically on save): $ cmake -S. -Bbuild And finally build it: $ cmake --build build This will produce an Objective-C library under build/tolc (with MSVC it will be under for example build/tolc/Debug ). In order to use it we create an Objective-C application and link it to our libraries: add_executable(Objecty objc/main.m) target_link_libraries(Objecty PRIVATE MyLib_objc) The Tolc CMake plugin has created targets that take care of the rest. From Objective-C : #import <Mylib.h> int main() { MyLibMyCppClass* myCppClass = [[MyLibMyCppClass alloc] init]; [myCppClass someMethod]; } If you want to see what more is supported you can take a look at the Examples section .","title":"Downloading and using Tolc"},{"location":"python/conversions/","text":"C++ to python conversions This page shows what is automatically translated and to what. On the left is the C++ and to the right what the corresponding interface in python will be. Not converted means there will be no automatic translation to a corresponding python object (for example std::queue does not automatically translate to queue.Queue ). Note that any restriction this poses only applies to the public interface of your code (e.g. your public headers). Conversion tables C++ Python translation Namespace Module Nested namespace Submodule Class Class Public function Class function Private function Not converted Virtual function Overridable function Operator Operator Static member function Static class function Static member variable Static class variable Public const member variable Read only property Public non const member variable Read write property Private member variable Not converted Global variable Module variable Global static variable Static module variable Free function Module function Overloaded function Module function* Enum Enum Scoped enum Enum Templated class/function Not converted** Specialized class template Class*** Specialized function template Function**** Documentation * Documentation * Will try to match arguments to types provided. ** No direct translation to python . Will not emit warning. *** The naming convention for these classes can be found under the Template Naming Convention page . **** Functions with different template arguments will behave as overloaded functions. ***** Refers to documentation comments before namespaces, functions, classes etc. See the examples for more information . C++ operator Python operator operator+ __add__ operator- __sub__ operator* __mul__ operator/ __truediv__ operator% __mod__ operator+= __iadd__ operator-= __isub__ operator*= __imul__ operator/= __itruediv__ operator%= __imod__ operator== __eq__ operator!= __ne__ operator> __gt__ operator>= __ge__ operator< __lt__ operator<= __ge__ operator[] __getitem__ operator() __call__ operator= Not converted operator<< Not converted operator>> Not converted operator++ Not converted operator-- Not converted C++ Standard library class Python translation std::array array std::complex complex std::deque array std::filesystem::path pathlib.Path std::forward_list Not converted std::function function std::list array std::map dict std::multimap Not converted std::multiset Not converted std::optional None || value std::pair tuple std::priority_queue Not converted std::queue Not converted std::set set std::shared_ptr value std::stack Not converted std::tuple tuple std::unique_ptr value* std::shared_ptr value** std::unordered_map dict std::unordered_multimap Not converted std::unordered_multiset Not converted std::unordered_set set std::valarray array std::variant value std::vector array * Note that due to how python works internally, function argument of type std::unique_ptr is not allowed. For more info see the pybind11 documentation on smart pointers . ** When a user defined struct/class is managed by std::shared_ptr , it is marked as such in the resulting pybind11. For more info see the pybind11 documentation on smart pointers . C++ builtin type Python translation bool bool char str char16_t str char32_t str double float float float int int int8_t int int16_t int int32_t int int64_t int long double int long int int long long int int short int int signed char str string str string_view str uint8_t int uint16_t int uint32_t int uint64_t int unsigned char str unsigned int int unsigned long int int unsigned long long int int unsigned short int int wchar_t str","title":"Conversions"},{"location":"python/conversions/#c-to-python-conversions","text":"This page shows what is automatically translated and to what. On the left is the C++ and to the right what the corresponding interface in python will be. Not converted means there will be no automatic translation to a corresponding python object (for example std::queue does not automatically translate to queue.Queue ). Note that any restriction this poses only applies to the public interface of your code (e.g. your public headers).","title":"C++ to python conversions"},{"location":"python/conversions/#conversion-tables","text":"C++ Python translation Namespace Module Nested namespace Submodule Class Class Public function Class function Private function Not converted Virtual function Overridable function Operator Operator Static member function Static class function Static member variable Static class variable Public const member variable Read only property Public non const member variable Read write property Private member variable Not converted Global variable Module variable Global static variable Static module variable Free function Module function Overloaded function Module function* Enum Enum Scoped enum Enum Templated class/function Not converted** Specialized class template Class*** Specialized function template Function**** Documentation * Documentation * Will try to match arguments to types provided. ** No direct translation to python . Will not emit warning. *** The naming convention for these classes can be found under the Template Naming Convention page . **** Functions with different template arguments will behave as overloaded functions. ***** Refers to documentation comments before namespaces, functions, classes etc. See the examples for more information . C++ operator Python operator operator+ __add__ operator- __sub__ operator* __mul__ operator/ __truediv__ operator% __mod__ operator+= __iadd__ operator-= __isub__ operator*= __imul__ operator/= __itruediv__ operator%= __imod__ operator== __eq__ operator!= __ne__ operator> __gt__ operator>= __ge__ operator< __lt__ operator<= __ge__ operator[] __getitem__ operator() __call__ operator= Not converted operator<< Not converted operator>> Not converted operator++ Not converted operator-- Not converted C++ Standard library class Python translation std::array array std::complex complex std::deque array std::filesystem::path pathlib.Path std::forward_list Not converted std::function function std::list array std::map dict std::multimap Not converted std::multiset Not converted std::optional None || value std::pair tuple std::priority_queue Not converted std::queue Not converted std::set set std::shared_ptr value std::stack Not converted std::tuple tuple std::unique_ptr value* std::shared_ptr value** std::unordered_map dict std::unordered_multimap Not converted std::unordered_multiset Not converted std::unordered_set set std::valarray array std::variant value std::vector array * Note that due to how python works internally, function argument of type std::unique_ptr is not allowed. For more info see the pybind11 documentation on smart pointers . ** When a user defined struct/class is managed by std::shared_ptr , it is marked as such in the resulting pybind11. For more info see the pybind11 documentation on smart pointers . C++ builtin type Python translation bool bool char str char16_t str char32_t str double float float float int int int8_t int int16_t int int32_t int int64_t int long double int long int int long long int int short int int signed char str string str string_view str uint8_t int uint16_t int uint32_t int uint64_t int unsigned char str unsigned int int unsigned long int int unsigned long long int int unsigned short int int wchar_t str","title":"Conversion tables"},{"location":"python/examples/","text":"Examples Each example is taken from the test suite for Tolc and, given that you use the latest version, you can expect them all to work. Each C++ library named MyLib exports as a python module called MyLib , in every test the module name is simply m for brevity. All tests use the python builtin unittest library. The examples that follow contains a bit of C++ code, and the respective python code using it. Each python example is wrapped in the following boilerplate that is removed to make the examples more readable: import unittest import m class TestMyLib(unittest.TestCase): @classmethod def setUpClass(cls): pass def test_m(self): # The actual python example body goes here self.assertEqual(m.sayTen(), 10) if __name__ == \"__main__\": unittest.main() Classes #include <string> #include <string_view> class WithConstructor { public: explicit WithConstructor(std::string s) : m_s(s) {} static int const i = 5; // This class has a readwrite variable int readwrite = 10; std::string getS() { return m_s; } std::string_view getSView() { return m_s; } private: std::string m_s; }; class WithFunction { public: int add(int i, int j) { return i + j; } }; class WithPrivateFunction { double multiply(double i, double j) { return i * j; } }; namespace MyLib { class Nested { public: double divideByTwo(double d) { return d / 2; } }; } /** Documentation carries over */ struct Documentation {}; /***************************** * JavaDoc Style * is * boxy ****************************/ struct JavaDoc {}; # You can access static variables without instantiating class self.assertEqual(m.WithConstructor.i, 5) # Creating classes via their constructor with_constructor = m.WithConstructor(\"Hello\") self.assertEqual(with_constructor.getS(), \"Hello\") # Documentation for variables carries over aswell self.assertIn(\"This class has a readwrite variable\", m.WithConstructor.readwrite.__doc__) # Named arguments in constructors with_constructor = m.WithConstructor(s=\"named argument\") self.assertEqual(with_constructor.getS(), \"named argument\") self.assertEqual(with_constructor.getSView(), \"named argument\") # Member functions are available after construction with_function = m.WithFunction() self.assertEqual(with_function.add(2, 5), 7) # Private functions have no bindings with self.assertRaises(AttributeError) as error_context: with_private_function = m.WithPrivateFunction() with_private_function.multiply(3, 2) self.assertEqual(len(error_context.exception.args), 1) # print(error_context.test_case) self.assertEqual( \"'m.WithPrivateFunction' object has no attribute 'multiply'\", error_context.exception.args[0], \"Not correct exception on private functions\", ) # Classes under namespaces are available under the corresponding submodule nested = m.MyLib.Nested() self.assertEqual(nested.divideByTwo(10), 5) # Different styles of documentation on classes carries over self.assertIn(\"Documentation carries over\", m.Documentation.__doc__) self.assertIn(\"JavaDoc Style\", m.JavaDoc.__doc__) Documentation Styles // One line comment class OneLiner {}; /** Single multi line comment */ class SingleMulti {}; /** * Multi * line * comment */ class Multi {}; /** Bare multi Another line */ class BareMulti {}; /*! * Qt style */ class QtStyle {}; /***************************** * JavaDoc Style * is * boxy ****************************/ class JavaDoc {}; /// /// Triplets is a commitment /// class Triplets {}; //! //! This is one of the doxy styles //! class DoxyBang {}; # These types of documentations are supported for: # Classes # Member variables # Enums # Functions self.assertIn(\"One line comment\", m.OneLiner.__doc__) self.assertIn(\"Single multi line\", m.SingleMulti.__doc__) self.assertIn(\"Multi\", m.Multi.__doc__) self.assertIn(\"Bare multi\", m.BareMulti.__doc__) self.assertIn(\"Qt style\", m.QtStyle.__doc__) self.assertIn(\"JavaDoc Style\", m.JavaDoc.__doc__) self.assertIn(\"Triplets\", m.Triplets.__doc__) self.assertIn(\"one of the doxy styles\", m.DoxyBang.__doc__) Enums enum Unscoped { Under, Uboat, }; enum class Scoped { Sacred, Snail, }; class EnumTest { public: explicit EnumTest(Scoped _s) : s(_s) {}; Scoped s; }; Unscoped f(Unscoped u) { return u; } namespace NS { // Documentation describing the enum enum class Deep { Double, Down, }; } # C++11 enums work scoped = m.Scoped.Snail enumTest = m.EnumTest(scoped) self.assertEqual(enumTest.s, scoped) # Aswell as legacy enums unscoped = m.Unscoped.Uboat u = m.f(unscoped) self.assertEqual(u, unscoped) # Enums under namespaces are available under the corresponding submodule deep = m.NS.Deep.Down self.assertNotEqual(deep, m.NS.Deep.Double) # Documentation carries over from C++ self.assertIn(\"Documentation describing the enum\", m.NS.Deep.__doc__) Functions #include <fstream> #include <string> void sayHello() { std::ofstream f(\"hello.txt\"); f << \"Hello!\"; f.close(); } void addYourOwn(std::string content) { std::ofstream f(\"hello.txt\"); f << content; f.close(); } /** * Documentation carries over */ int calculate() { return 5; } // Different documentation styles are supported int missingArgumentsNaming(int, int i) { return i; } char firstLetter(std::string_view s) { return s[0]; } int static getZero() { return 0; } m.sayHello() with open(\"hello.txt\", \"r\") as f: self.assertEqual(f.readline(), \"Hello!\") content = \"This is from python!\" m.addYourOwn(content) with open(\"hello.txt\", \"r\") as f: self.assertEqual(f.readline(), content) result = m.calculate() self.assertEqual(result, 5) self.assertIn(\"Documentation carries over\", m.calculate.__doc__) # Without naming variables is fine result = m.missingArgumentsNaming(2, 5) self.assertEqual(result, 5) self.assertIn(\"Different documentation styles are supported\", \\ m.missingArgumentsNaming.__doc__) # Not possible to name any variables unless they are all known with self.assertRaises(TypeError) as error_context: result = m.missingArgumentsNaming(2, i=5) # std::string_view works fine result = m.firstLetter(\"Hello\") self.assertEqual(result, \"H\") # Static functions are just normal module functions in python self.assertEqual(m.getZero(), 0) Global Variables #include <string> static int i = 0; namespace Nested { int i = 0; std::string s = \"Hello world\"; } # Starts at 0 and can be changed self.assertEqual(m.i, 0) m.i = 5 self.assertEqual(m.i, 5) # Nested with the same name self.assertEqual(m.Nested.i, 0) # More complex variables are available aswell self.assertEqual(m.Nested.s, \"Hello world\") Inheritence #include <string> struct Pet { Pet(const std::string &name) : name(name) { } std::string name; }; struct Dog : public Pet { Dog(const std::string &name) : Pet(name) { } std::string bark() const { return \"woof!\"; } }; fido = m.Dog(\"Fido\") # Inherits public properties self.assertEqual(fido.name, \"Fido\") # But has its new functions self.assertEqual(fido.bark(), \"woof!\") Member Variables #include <string> class SimpleMember { public: explicit SimpleMember() : myString(\"Hello\") {} std::string myString; }; class ConstMember { public: const int i = 42; }; class PrivateMember { public: explicit PrivateMember(std::string s) : myString(s) {} private: std::string myString; }; namespace MyLib { class Nested { public: double d = 4.3; }; } # Mutable member variables can be changed simpleMember = m.SimpleMember() self.assertEqual(simpleMember.myString, \"Hello\") simpleMember.myString = \"Changed now!\" self.assertEqual(simpleMember.myString, \"Changed now!\") constMember = m.ConstMember() self.assertEqual(constMember.i, 42) # Const member variables cannot be changed with self.assertRaises(AttributeError) as error_context: constMember.i = 0 self.assertEqual(len(error_context.exception.args), 1) self.assertEqual( \"can't set attribute\", error_context.exception.args[0], \"Prohibiting changing const variables does not work!\", ) # Private member variables are not available with self.assertRaises(AttributeError) as error_context: privateMember = m.PrivateMember(\"Hello\") print(privateMember.myString) self.assertEqual(len(error_context.exception.args), 1) self.assertEqual( \"'m.PrivateMember' object has no attribute 'myString'\", error_context.exception.args[0], \"Prohibiting changing const variables does not work!\", ) nested = m.MyLib.Nested() self.assertEqual(nested.d, 4.3) Namespaces #include <string> /* * MyLib contains a bunch of MyLib functions */ namespace MyLib { int complexFunction() { return 5; } namespace We { namespace Are { namespace Going { namespace Pretty { namespace Deep { std::string meaningOfLife() { return \"42\"; } } } } } } } # Namespaces corresponds to submodules result = m.MyLib.complexFunction() self.assertEqual(result, 5) # Documentation carries over for namespaces self.assertIn(\"MyLib contains a bunch of MyLib functions\", \\ m.MyLib.__doc__) # You can nest namespaces arbitrarily deep lifeProTips = m.MyLib.We.Are.Going.Pretty.Deep.meaningOfLife() self.assertEqual(lifeProTips, \"42\") Operators #include <string> class MyClass { public: explicit MyClass(int v) : value(v) {} // +-*/& MyClass operator+(int i) { return MyClass(value + i); } MyClass operator-(int i) { return MyClass(value - i); } MyClass operator*(int i) { return MyClass(value * i); } MyClass operator/(int i) { return MyClass(value / i); } MyClass operator%(int i) { return MyClass(value % i); } // Assignment MyClass& operator+=(const MyClass& rhs) { value += rhs.value; return *this; } MyClass& operator-=(const MyClass& rhs) { value -= rhs.value; return *this; } MyClass& operator*=(const MyClass& rhs) { value *= rhs.value; return *this; } MyClass& operator/=(const MyClass& rhs) { value /= rhs.value; return *this; } MyClass& operator%=(const MyClass& rhs) { value %= rhs.value; return *this; } // Comparisons bool operator==(const MyClass &rhs) { return value == rhs.value; } bool operator!=(const MyClass &rhs) { return value != rhs.value; } bool operator<(const MyClass &rhs) { return value < rhs.value; } bool operator>(const MyClass &rhs) { return value > rhs.value; } bool operator<=(const MyClass &rhs) { return value <= rhs.value; } bool operator>=(const MyClass &rhs) { return value >= rhs.value; } // Subscript MyClass operator[](unsigned idx) { return MyClass(static_cast<int>(idx)); } // Call int operator()(int x) { return value + x; } std::string operator()(std::string const& x) { return x + std::to_string(value); } int value; }; my_class = m.MyClass(10) self.assertEqual(my_class.value, 10) # Normal operators translate as expected self.assertEqual((my_class + 5).value, 15) self.assertEqual((my_class - 5).value, 5) self.assertEqual((my_class * 5).value, 50) self.assertEqual((my_class / 5).value, 2) self.assertEqual((my_class % 3).value, 1) other = m.MyClass(5) # Comparison operators self.assertTrue(my_class != other) self.assertTrue(my_class > other) self.assertTrue(my_class >= other) self.assertFalse(my_class == other) self.assertFalse(my_class < other) self.assertFalse(my_class <= other) # Can also use the {operator}= functions # other.value = 5 my_class += other self.assertEqual(my_class.value, 15) my_class -= other self.assertEqual(my_class.value, 10) my_class *= other self.assertEqual(my_class.value, 50) my_class /= other self.assertEqual(my_class.value, 10) my_class %= other self.assertEqual(my_class.value, 0) # Subscript [] self.assertEqual(my_class[100].value, 100) # Call () self.assertEqual(my_class(100), 100) # Overloading works self.assertEqual(my_class(\"The inner value is: \"), \"The inner value is: 0\") Overloaded Functions #include <string> // Overloaded free functions std::string sayHello() { return \"Hello!\"; } std::string sayHello(std::string to) { return std::string(\"Hello \") + to; } std::string safety() { return \"Safe!\"; } class Overload { public: // Overloaded constructor Overload() {}; Overload(std::string) {}; // Overloaded class functions std::string getStuff() { return \"Stuff\"; } std::string getStuff(std::string customStuff) { return customStuff; } std::string safety() { return \"Safe!\"; } }; # Overloaded functions work the same as in C++ # Free function overload self.assertEqual(m.sayHello(), \"Hello!\") self.assertEqual(m.sayHello(\"to me!\"), \"Hello to me!\") # Class function overload overload = m.Overload() overload = m.Overload(\"Overloaded!\") self.assertEqual(overload.getStuff(), \"Stuff\") self.assertEqual(overload.getStuff(\"My stuff\"), \"My stuff\") self.assertEqual(overload.safety(), \"Safe!\") self.assertEqual(overload.safety(), m.safety()) Overriding virtual functions in python #include <string> class Animal { public: virtual ~Animal() { } virtual std::string sound(int n_times, bool grumpy) = 0; }; class Dog : public Animal { public: std::string sound(int n_times, bool grumpy) override { if (grumpy) { return \"No.\"; } std::string result; for (int i = 0; i < n_times; ++i) { result += \"woof! \"; } return result; } }; std::string call_sound(Animal *animal) { return animal->sound(3, false); } fido = m.Dog() grumpy = True # Overloaded function in C++ self.assertEqual(fido.sound(1, not grumpy), \"woof! \") # Polymorphic function in C++ self.assertEqual(m.call_sound(fido), \"woof! woof! woof! \") # Inherit from virtual C++ classes in python class Cat(m.Animal): # Override C++ function def sound(self, n_times, grumpy): return \"No.\" if grumpy else \"meow! \" * n_times whiskers = Cat() # Overloaded C++ function in python self.assertEqual(whiskers.sound(1, grumpy), \"No.\") self.assertEqual(whiskers.sound(1, not grumpy), \"meow! \") # Polymorphic function in C++ called with python object self.assertEqual(m.call_sound(whiskers), \"meow! meow! meow! \") Overriding virtual in python #include <string> class Animal { public: virtual ~Animal() { } virtual std::string sound(int n_times, bool grumpy) = 0; }; class Dog : public Animal { public: std::string sound(int n_times, bool grumpy) override { if (grumpy) { return \"No.\"; } std::string result; for (int i = 0; i < n_times; ++i) { result += \"woof! \"; } return result; } }; std::string call_sound(Animal *animal) { return animal->sound(3, false); } fido = m.Dog() grumpy = True # Overloaded function in C++ self.assertEqual(fido.sound(1, grumpy), \"No.\") self.assertEqual(fido.sound(1, not grumpy), \"woof! \") # Polymorphic function in C++ self.assertEqual(m.call_sound(fido), \"woof! woof! woof! \") # Inherit from virtual C++ classes in python class Cat(m.Animal): # Override C++ function def sound(self, n_times, grumpy): return \"No.\" if grumpy else \"meow! \" * n_times whiskers = Cat() # Overloaded C++ function in python self.assertEqual(whiskers.sound(1, grumpy), \"No.\") self.assertEqual(whiskers.sound(1, not grumpy), \"meow! \") # Polymorphic function in C++ called with python object self.assertEqual(m.call_sound(whiskers), \"meow! meow! meow! \") Simple inheritence #include <string> struct Pet { Pet(const std::string &name) : name(name) { } std::string name; }; struct Dog : public Pet { Dog(const std::string &name) : Pet(name) { } std::string bark() const { return \"woof!\"; } }; fido = m.Dog(\"Fido\") # Inherits public properties self.assertEqual(fido.name, \"Fido\") # But has its new functions self.assertEqual(fido.bark(), \"woof!\") Smart Pointers #include <memory> struct Example { int m_hi = 5; }; struct ExampleShared { int m_hi = 10; }; std::unique_ptr<Example> create_unique() { return std::make_unique<Example>(); } std::shared_ptr<ExampleShared> create_shared() { return std::make_shared<ExampleShared>(); } # std::unique_ptr acts as a normal value # Note that passing a std::unique_ptr as an argument gives an error # See https://pybind11.readthedocs.io/en/stable/advanced/smart_ptrs.html u = m.create_unique() self.assertEqual(u.m_hi, 5) # std::shared_ptr acts as a normal value s = m.create_shared() self.assertEqual(s.m_hi, 10) std::array #include <array> #include <string> class WithMember { public: explicit WithMember(std::array<std::string, 2> s) : m_s(s) {} std::array<std::string, 2> getS() { return m_s; } private: std::array<std::string, 2> m_s; }; class WithFunction { public: int sum(std::array<int, 5> v) { int s = 0; for (auto i : v) { s += i; } return s; } }; # std::array translates to a normal array in python my_array = [\"hi\", \"ho\"] with_member = m.WithMember(my_array) self.assertEqual(with_member.getS(), my_array) with_function = m.WithFunction() self.assertEqual(with_function.sum([1, 2, 3, 4, 5]), 15) # It still corresponds to a fixed amount of elements for incompatible_array in [[\"too many\", \"too many\", \"too many\"], [\"too few\"]]: with self.assertRaises(TypeError) as error_context: with_member = m.WithMember(incompatible_array) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \" + str(error_context.exception.args[0]), ) self.assertTrue( \"Invoked with: \" + str(incompatible_array) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \" + str(error_context.exception.args[0]), ) std::complex #include <complex> using namespace std::complex_literals; std::complex<int> i() { return 5; } std::complex<double> d() { return 1. + 2i; } std::complex<float> f() { return 0.f + 5if; } std::complex<double> r(std::complex<double> d) { return d; } # std::complex translates to a complex in python i = m.i() self.assertEqual(i.real, 5) self.assertEqual(i.imag, 0) d = m.d() self.assertEqual(d.real, 1) self.assertEqual(d.imag, 2) f = m.f() self.assertEqual(f.real, 0) self.assertEqual(f.imag, 5) # Using python builtin complex class r = m.r(complex(1, 2)) self.assertEqual(r.real, 1) self.assertEqual(r.imag, 2) std::deque #include <string> #include <deque> class WithMember { public: explicit WithMember(std::deque<std::string> s) : m_s(s) {} std::deque<std::string> getS() { return m_s; } private: std::deque<std::string> m_s; }; class WithFunction { public: int sum(std::deque<int> v) { int s = 0; for (auto i : v) { s += i; } return s; } }; # std::deque translates to a normal array in python my_array = [\"hi\", \"ho\"] with_member = m.WithMember(my_array) self.assertEqual(with_member.getS(), my_array) with_function = m.WithFunction() self.assertEqual(with_function.sum([1, 2, 3]), 6) std::filesystem::path #include <filesystem> #include <vector> std::filesystem::path takingPath(std::filesystem::path p) { return p; } std::string toString(std::filesystem::path p) { return p.string(); } std::filesystem::path joinPaths(std::vector<std::filesystem::path> arrayToSum) { std::filesystem::path sum; for (auto f : arrayToSum) { sum /= f; } return sum; } # std::filesystem::path translates to pathlib.Path in python from pathlib import Path p0 = Path(\"Hello\") result0 = m.takingPath(p0) self.assertEqual(result0, p0) p1 = Path(\"Something\") toString = m.toString(p1) self.assertEqual(toString, p1.name) result1 = m.joinPaths([p0, p1]) self.assertEqual(result1, p0 / p1) std::function #include <functional> #include <vector> double takingFunction(std::function<double(int)> callMe) { return callMe(5); } std::function<int(int)> returnFunction(const std::function<int(int)> &f) { return [f](int i) { return f(i) + 1; }; } int accumulateArrayOfFunctions(std::vector<std::function<int()>> arrayToSum) { int sum = 0; for (auto f : arrayToSum) { sum += f(); } return sum; } def callback(i): return i # You can send a python function as a C++ callback result0 = m.takingFunction(callback) self.assertEqual(result0, 5.0) # Or in the other direction inc_by_one = m.returnFunction(callback) self.assertEqual(inc_by_one(5), 6) def fiver(): return 5 # Or a vector of functions result1 = m.accumulateArrayOfFunctions([fiver, fiver]) self.assertEqual(result1, 10) std::list #include <string> #include <list> class WithMember { public: explicit WithMember(std::list<std::string> s) : m_s(s) {} std::list<std::string> getS() { return m_s; } private: std::list<std::string> m_s; }; class WithFunction { public: int sum(std::list<int> v) { int s = 0; for (auto i : v) { s += i; } return s; } }; # std::list translates to a normal array in python my_array = [\"hi\", \"ho\"] with_member = m.WithMember(my_array) self.assertEqual(with_member.getS(), my_array) with_function = m.WithFunction() self.assertEqual(with_function.sum([1, 2, 3]), 6) std::map #include <map> #include <string> class MyClass { public: explicit MyClass(std::map<std::string, int> s) : m_s(s) {} std::map<std::string, int> getS() { return m_s; } std::string getValue(std::map<int, std::string> const& m, int key) { auto it = m.find(key); if (it != m.end()) { return it->second; } return \"\"; } private: std::map<std::string, int> m_s; }; # std::map translates to a normal dictionary in python my_map = {\"hi\": 4, \"ho\": 5} c = m.MyClass(my_map) self.assertEqual(c.getS(), my_map) # The maps are typed on the C++ side for incopatible_map in [{\"key\": \"value\"}, {5: 2}]: with self.assertRaises(TypeError) as error_context: c = m.MyClass(incopatible_map) c.getValue(incopatible_map, 5) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible function arguments\" in error_context.exception.args[0] or \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \\n\\t\" + str(error_context.exception.args[0]), ) self.assertTrue( str(incopatible_map) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \\n\\t\" + str(error_context.exception.args[0]), ) std::optional #include <optional> #include <string> class WithMember { public: explicit WithMember(std::optional<std::string> s) : m_s(s) {} std::optional<std::string> getS() { return m_s; } private: std::optional<std::string> m_s; }; class WithFunction { public: std::optional<int> getNullopt() { return std::nullopt; } }; # std::optional is either the value or None in python greeting = \"hello\" with_member = m.WithMember(greeting) self.assertEqual(with_member.getS(), greeting) with_function = m.WithFunction() self.assertEqual(with_function.getNullopt(), None) std::pair #include <string> class MyClass { public: explicit MyClass(std::pair<std::string, int> s) : m_s(s) {} std::pair<std::string, int> getS() { return m_s; } private: std::pair<std::string, int> m_s; }; class WithFunction { public: int sum(std::pair<int, int> v) { return v.first + v.second; } }; # Converts to a tuple, but is convertible from array aswell my_array = [\"hi\", 4] for t in [my_array, tuple(my_array)]: with_member = m.MyClass(t) self.assertEqual(with_member.getS(), tuple(t)) with_function = m.WithFunction() self.assertEqual(with_function.sum((1, 2)), 3) std::set #include <set> #include <string> class MyClass { public: explicit MyClass(std::set<std::string> s) : m_s(s) {} std::set<std::string> getS() { return m_s; } int getValue(std::set<int> const& m, int key) { auto it = m.find(key); if (it != m.end()) { return *it; } return -1; } private: std::set<std::string> m_s; }; # std::set translates to a normal array or a set in python mySet = {\"hi\", \"this is a set\"} c = m.MyClass(mySet) self.assertEqual(c.getS(), mySet) self.assertEqual(c.getValue({1, 2, 3}, 3), 3) self.assertEqual(c.getValue({1, 2, 3}, 4), -1) # Test set of the wrong type for incompatibleset in [{\"key\": \"value\"}, (5, 2)]: with self.assertRaises(TypeError) as error_context: c = m.MyClass(incompatibleset) c.getValue(incompatibleset, 5) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible function arguments\" in error_context.exception.args[0] or \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \\n\\t\" + str(error_context.exception.args[0]), ) self.assertTrue( str(incompatibleset) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \\n\\t\" + str(error_context.exception.args[0]), ) std::tuple #include <string> #include <tuple> class MyClass { public: explicit MyClass(std::tuple<std::string, int> s) : m_s(s) {} std::tuple<std::string, int> getS() { return m_s; } std::tuple<std::string, int> m_s; }; class WithFunction { public: double sum(std::tuple<int, int, float, double> t) { return std::get<0>(t) + std::get<1>(t) + std::get<2>(t) + std::get<3>(t); } }; # Converts to a tuple, but is convertible from array aswell my_array = [\"hi\", 4] for t in [my_array, tuple(my_array)]: with_member = m.MyClass(t) self.assertEqual(with_member.getS(), tuple(t)) with_function = m.WithFunction() self.assertAlmostEqual(with_function.sum((1, 2, 3.3, 2.0)), 8.3, delta=0.0001) std::unordered_map #include <string> #include <unordered_map> class MyClass { public: explicit MyClass(std::unordered_map<std::string, int> s) : m_s(s) {} std::unordered_map<std::string, int> getS() { return m_s; } std::string getValue(std::unordered_map<int, std::string> const& m, int key) { auto it = m.find(key); if (it != m.end()) { return it->second; } return \"\"; } private: std::unordered_map<std::string, int> m_s; }; # std::unordered_map translates to a normal dictionary in python myunordered_map = {\"hi\": 4, \"ho\": 5} c = m.MyClass(myunordered_map) self.assertEqual(c.getS(), myunordered_map) # Test unordered_map of the wrong type for incompatible_map in [{\"key\": \"value\"}, {5: 2}]: with self.assertRaises(TypeError) as error_context: c = m.MyClass(incompatible_map) c.getValue(incompatible_map, 5) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible function arguments\" in error_context.exception.args[0] or \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \\n\\t\" + str(error_context.exception.args[0]), ) self.assertTrue( str(incompatible_map) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \\n\\t\" + str(error_context.exception.args[0]), ) std::unordered_set #include <string> #include <unordered_set> class MyClass { public: explicit MyClass(std::unordered_set<std::string> s) : m_s(s) {} std::unordered_set<std::string> getS() { return m_s; } int getValue(std::unordered_set<int> const& m, int key) { auto it = m.find(key); if (it != m.end()) { return *it; } return -1; } private: std::unordered_set<std::string> m_s; }; # std::unordered_set translates to a normal array or a set in python my_unordered_set = {\"hi\", \"this is a unordered_set\"} c = m.MyClass(my_unordered_set) self.assertEqual(c.getS(), my_unordered_set) self.assertEqual(c.getValue({1, 2, 3}, 3), 3) self.assertEqual(c.getValue({1, 2, 3}, 4), -1) # Test unordered_set of the wrong type for incompatible_set in [{\"key\": \"value\"}, (5, 2)]: with self.assertRaises(TypeError) as error_context: c = m.MyClass(incompatible_set) c.getValue(incompatible_set, 5) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible function arguments\" in error_context.exception.args[0] or \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \\n\\t\" + str(error_context.exception.args[0]), ) self.assertTrue( str(incompatible_set) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \\n\\t\" + str(error_context.exception.args[0]), ) std::valarray #include <valarray> std::valarray<int> get() { return {1, 2, 3}; } v = m.get() self.assertEqual(v, [1, 2, 3]) std::variant #include <string> #include <variant> class WithMember { public: explicit WithMember(std::variant<int, bool> s) : m_s(s) {} std::variant<int, bool> getS() { return m_s; } private: std::variant<int, bool> m_s; }; class WithFunction { public: std::variant<int, std::string, bool> getFive() { return 5; } std::variant<int, std::string, bool> getHello() { return std::string(\"Hello\"); } std::variant<int, std::string, bool> getTrue() { return true; } }; # std::variant translates to one of the values in python number = 6 withNumber = m.WithMember(number) self.assertEqual(withNumber.getS(), number) withBool = m.WithMember(True) self.assertEqual(withBool.getS(), True) with_function = m.WithFunction() self.assertEqual(with_function.getFive(), 5) self.assertEqual(with_function.getHello(), \"Hello\") self.assertEqual(with_function.getTrue(), True) std::vector #include <string> #include <vector> class WithMember { public: explicit WithMember(std::vector<std::string> s) : m_s(s) {} std::vector<std::string> getS() { return m_s; } private: std::vector<std::string> m_s; }; class WithFunction { public: int sum(std::vector<int> v) { int s = 0; for (auto i : v) { s += i; } return s; } }; # std::vector translates to a normal array in python my_array = [\"hi\", \"ho\"] with_member = m.WithMember(my_array) self.assertEqual(with_member.getS(), my_array) with_function = m.WithFunction() self.assertEqual(with_function.sum([1, 2, 3]), 6) Templates #include <array> #include <map> #include <string> #include <vector> template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string something); template int getSomething(int); template std::vector<std::string> getSomething(std::vector<std::string>); template <typename T> class MyClass { public: T myFun(T type) { return type; } }; template class MyClass<int>; template class MyClass<std::map<char, std::vector<int>>>; template class MyClass<std::array<int, 3>>; # getSomething<std::string> hi = m.getSomething(\"hi\") self.assertEqual(hi, \"hi\") # getSomething<int> five = m.getSomething(5) self.assertEqual(five, 5) # getSomething<std::vector<std::string>> l = m.getSomething([\"hi\"]) self.assertEqual(l, [\"hi\"]) # MyClass<int> my_class_int = m.MyClass_int() self.assertEqual(my_class_int.myFun(25), 25) # MyClass<std::map<char, std::vector<int>>> my_class_map = m.MyClass_map_char_vector_int() self.assertEqual(my_class_map.myFun({'h': [1]}), {'h': [1]}) # MyClass<std::array<int, 3>> my_class_array = m.MyClass_array_int_3() self.assertEqual(my_class_array.myFun([1, 2, 3]), [1, 2, 3])","title":"Examples"},{"location":"python/examples/#examples","text":"Each example is taken from the test suite for Tolc and, given that you use the latest version, you can expect them all to work. Each C++ library named MyLib exports as a python module called MyLib , in every test the module name is simply m for brevity. All tests use the python builtin unittest library. The examples that follow contains a bit of C++ code, and the respective python code using it. Each python example is wrapped in the following boilerplate that is removed to make the examples more readable: import unittest import m class TestMyLib(unittest.TestCase): @classmethod def setUpClass(cls): pass def test_m(self): # The actual python example body goes here self.assertEqual(m.sayTen(), 10) if __name__ == \"__main__\": unittest.main()","title":"Examples"},{"location":"python/examples/#classes","text":"#include <string> #include <string_view> class WithConstructor { public: explicit WithConstructor(std::string s) : m_s(s) {} static int const i = 5; // This class has a readwrite variable int readwrite = 10; std::string getS() { return m_s; } std::string_view getSView() { return m_s; } private: std::string m_s; }; class WithFunction { public: int add(int i, int j) { return i + j; } }; class WithPrivateFunction { double multiply(double i, double j) { return i * j; } }; namespace MyLib { class Nested { public: double divideByTwo(double d) { return d / 2; } }; } /** Documentation carries over */ struct Documentation {}; /***************************** * JavaDoc Style * is * boxy ****************************/ struct JavaDoc {}; # You can access static variables without instantiating class self.assertEqual(m.WithConstructor.i, 5) # Creating classes via their constructor with_constructor = m.WithConstructor(\"Hello\") self.assertEqual(with_constructor.getS(), \"Hello\") # Documentation for variables carries over aswell self.assertIn(\"This class has a readwrite variable\", m.WithConstructor.readwrite.__doc__) # Named arguments in constructors with_constructor = m.WithConstructor(s=\"named argument\") self.assertEqual(with_constructor.getS(), \"named argument\") self.assertEqual(with_constructor.getSView(), \"named argument\") # Member functions are available after construction with_function = m.WithFunction() self.assertEqual(with_function.add(2, 5), 7) # Private functions have no bindings with self.assertRaises(AttributeError) as error_context: with_private_function = m.WithPrivateFunction() with_private_function.multiply(3, 2) self.assertEqual(len(error_context.exception.args), 1) # print(error_context.test_case) self.assertEqual( \"'m.WithPrivateFunction' object has no attribute 'multiply'\", error_context.exception.args[0], \"Not correct exception on private functions\", ) # Classes under namespaces are available under the corresponding submodule nested = m.MyLib.Nested() self.assertEqual(nested.divideByTwo(10), 5) # Different styles of documentation on classes carries over self.assertIn(\"Documentation carries over\", m.Documentation.__doc__) self.assertIn(\"JavaDoc Style\", m.JavaDoc.__doc__)","title":"Classes"},{"location":"python/examples/#documentation-styles","text":"// One line comment class OneLiner {}; /** Single multi line comment */ class SingleMulti {}; /** * Multi * line * comment */ class Multi {}; /** Bare multi Another line */ class BareMulti {}; /*! * Qt style */ class QtStyle {}; /***************************** * JavaDoc Style * is * boxy ****************************/ class JavaDoc {}; /// /// Triplets is a commitment /// class Triplets {}; //! //! This is one of the doxy styles //! class DoxyBang {}; # These types of documentations are supported for: # Classes # Member variables # Enums # Functions self.assertIn(\"One line comment\", m.OneLiner.__doc__) self.assertIn(\"Single multi line\", m.SingleMulti.__doc__) self.assertIn(\"Multi\", m.Multi.__doc__) self.assertIn(\"Bare multi\", m.BareMulti.__doc__) self.assertIn(\"Qt style\", m.QtStyle.__doc__) self.assertIn(\"JavaDoc Style\", m.JavaDoc.__doc__) self.assertIn(\"Triplets\", m.Triplets.__doc__) self.assertIn(\"one of the doxy styles\", m.DoxyBang.__doc__)","title":"Documentation Styles"},{"location":"python/examples/#enums","text":"enum Unscoped { Under, Uboat, }; enum class Scoped { Sacred, Snail, }; class EnumTest { public: explicit EnumTest(Scoped _s) : s(_s) {}; Scoped s; }; Unscoped f(Unscoped u) { return u; } namespace NS { // Documentation describing the enum enum class Deep { Double, Down, }; } # C++11 enums work scoped = m.Scoped.Snail enumTest = m.EnumTest(scoped) self.assertEqual(enumTest.s, scoped) # Aswell as legacy enums unscoped = m.Unscoped.Uboat u = m.f(unscoped) self.assertEqual(u, unscoped) # Enums under namespaces are available under the corresponding submodule deep = m.NS.Deep.Down self.assertNotEqual(deep, m.NS.Deep.Double) # Documentation carries over from C++ self.assertIn(\"Documentation describing the enum\", m.NS.Deep.__doc__)","title":"Enums"},{"location":"python/examples/#functions","text":"#include <fstream> #include <string> void sayHello() { std::ofstream f(\"hello.txt\"); f << \"Hello!\"; f.close(); } void addYourOwn(std::string content) { std::ofstream f(\"hello.txt\"); f << content; f.close(); } /** * Documentation carries over */ int calculate() { return 5; } // Different documentation styles are supported int missingArgumentsNaming(int, int i) { return i; } char firstLetter(std::string_view s) { return s[0]; } int static getZero() { return 0; } m.sayHello() with open(\"hello.txt\", \"r\") as f: self.assertEqual(f.readline(), \"Hello!\") content = \"This is from python!\" m.addYourOwn(content) with open(\"hello.txt\", \"r\") as f: self.assertEqual(f.readline(), content) result = m.calculate() self.assertEqual(result, 5) self.assertIn(\"Documentation carries over\", m.calculate.__doc__) # Without naming variables is fine result = m.missingArgumentsNaming(2, 5) self.assertEqual(result, 5) self.assertIn(\"Different documentation styles are supported\", \\ m.missingArgumentsNaming.__doc__) # Not possible to name any variables unless they are all known with self.assertRaises(TypeError) as error_context: result = m.missingArgumentsNaming(2, i=5) # std::string_view works fine result = m.firstLetter(\"Hello\") self.assertEqual(result, \"H\") # Static functions are just normal module functions in python self.assertEqual(m.getZero(), 0)","title":"Functions"},{"location":"python/examples/#global-variables","text":"#include <string> static int i = 0; namespace Nested { int i = 0; std::string s = \"Hello world\"; } # Starts at 0 and can be changed self.assertEqual(m.i, 0) m.i = 5 self.assertEqual(m.i, 5) # Nested with the same name self.assertEqual(m.Nested.i, 0) # More complex variables are available aswell self.assertEqual(m.Nested.s, \"Hello world\")","title":"Global Variables"},{"location":"python/examples/#inheritence","text":"#include <string> struct Pet { Pet(const std::string &name) : name(name) { } std::string name; }; struct Dog : public Pet { Dog(const std::string &name) : Pet(name) { } std::string bark() const { return \"woof!\"; } }; fido = m.Dog(\"Fido\") # Inherits public properties self.assertEqual(fido.name, \"Fido\") # But has its new functions self.assertEqual(fido.bark(), \"woof!\")","title":"Inheritence"},{"location":"python/examples/#member-variables","text":"#include <string> class SimpleMember { public: explicit SimpleMember() : myString(\"Hello\") {} std::string myString; }; class ConstMember { public: const int i = 42; }; class PrivateMember { public: explicit PrivateMember(std::string s) : myString(s) {} private: std::string myString; }; namespace MyLib { class Nested { public: double d = 4.3; }; } # Mutable member variables can be changed simpleMember = m.SimpleMember() self.assertEqual(simpleMember.myString, \"Hello\") simpleMember.myString = \"Changed now!\" self.assertEqual(simpleMember.myString, \"Changed now!\") constMember = m.ConstMember() self.assertEqual(constMember.i, 42) # Const member variables cannot be changed with self.assertRaises(AttributeError) as error_context: constMember.i = 0 self.assertEqual(len(error_context.exception.args), 1) self.assertEqual( \"can't set attribute\", error_context.exception.args[0], \"Prohibiting changing const variables does not work!\", ) # Private member variables are not available with self.assertRaises(AttributeError) as error_context: privateMember = m.PrivateMember(\"Hello\") print(privateMember.myString) self.assertEqual(len(error_context.exception.args), 1) self.assertEqual( \"'m.PrivateMember' object has no attribute 'myString'\", error_context.exception.args[0], \"Prohibiting changing const variables does not work!\", ) nested = m.MyLib.Nested() self.assertEqual(nested.d, 4.3)","title":"Member Variables"},{"location":"python/examples/#namespaces","text":"#include <string> /* * MyLib contains a bunch of MyLib functions */ namespace MyLib { int complexFunction() { return 5; } namespace We { namespace Are { namespace Going { namespace Pretty { namespace Deep { std::string meaningOfLife() { return \"42\"; } } } } } } } # Namespaces corresponds to submodules result = m.MyLib.complexFunction() self.assertEqual(result, 5) # Documentation carries over for namespaces self.assertIn(\"MyLib contains a bunch of MyLib functions\", \\ m.MyLib.__doc__) # You can nest namespaces arbitrarily deep lifeProTips = m.MyLib.We.Are.Going.Pretty.Deep.meaningOfLife() self.assertEqual(lifeProTips, \"42\")","title":"Namespaces"},{"location":"python/examples/#operators","text":"#include <string> class MyClass { public: explicit MyClass(int v) : value(v) {} // +-*/& MyClass operator+(int i) { return MyClass(value + i); } MyClass operator-(int i) { return MyClass(value - i); } MyClass operator*(int i) { return MyClass(value * i); } MyClass operator/(int i) { return MyClass(value / i); } MyClass operator%(int i) { return MyClass(value % i); } // Assignment MyClass& operator+=(const MyClass& rhs) { value += rhs.value; return *this; } MyClass& operator-=(const MyClass& rhs) { value -= rhs.value; return *this; } MyClass& operator*=(const MyClass& rhs) { value *= rhs.value; return *this; } MyClass& operator/=(const MyClass& rhs) { value /= rhs.value; return *this; } MyClass& operator%=(const MyClass& rhs) { value %= rhs.value; return *this; } // Comparisons bool operator==(const MyClass &rhs) { return value == rhs.value; } bool operator!=(const MyClass &rhs) { return value != rhs.value; } bool operator<(const MyClass &rhs) { return value < rhs.value; } bool operator>(const MyClass &rhs) { return value > rhs.value; } bool operator<=(const MyClass &rhs) { return value <= rhs.value; } bool operator>=(const MyClass &rhs) { return value >= rhs.value; } // Subscript MyClass operator[](unsigned idx) { return MyClass(static_cast<int>(idx)); } // Call int operator()(int x) { return value + x; } std::string operator()(std::string const& x) { return x + std::to_string(value); } int value; }; my_class = m.MyClass(10) self.assertEqual(my_class.value, 10) # Normal operators translate as expected self.assertEqual((my_class + 5).value, 15) self.assertEqual((my_class - 5).value, 5) self.assertEqual((my_class * 5).value, 50) self.assertEqual((my_class / 5).value, 2) self.assertEqual((my_class % 3).value, 1) other = m.MyClass(5) # Comparison operators self.assertTrue(my_class != other) self.assertTrue(my_class > other) self.assertTrue(my_class >= other) self.assertFalse(my_class == other) self.assertFalse(my_class < other) self.assertFalse(my_class <= other) # Can also use the {operator}= functions # other.value = 5 my_class += other self.assertEqual(my_class.value, 15) my_class -= other self.assertEqual(my_class.value, 10) my_class *= other self.assertEqual(my_class.value, 50) my_class /= other self.assertEqual(my_class.value, 10) my_class %= other self.assertEqual(my_class.value, 0) # Subscript [] self.assertEqual(my_class[100].value, 100) # Call () self.assertEqual(my_class(100), 100) # Overloading works self.assertEqual(my_class(\"The inner value is: \"), \"The inner value is: 0\")","title":"Operators"},{"location":"python/examples/#overloaded-functions","text":"#include <string> // Overloaded free functions std::string sayHello() { return \"Hello!\"; } std::string sayHello(std::string to) { return std::string(\"Hello \") + to; } std::string safety() { return \"Safe!\"; } class Overload { public: // Overloaded constructor Overload() {}; Overload(std::string) {}; // Overloaded class functions std::string getStuff() { return \"Stuff\"; } std::string getStuff(std::string customStuff) { return customStuff; } std::string safety() { return \"Safe!\"; } }; # Overloaded functions work the same as in C++ # Free function overload self.assertEqual(m.sayHello(), \"Hello!\") self.assertEqual(m.sayHello(\"to me!\"), \"Hello to me!\") # Class function overload overload = m.Overload() overload = m.Overload(\"Overloaded!\") self.assertEqual(overload.getStuff(), \"Stuff\") self.assertEqual(overload.getStuff(\"My stuff\"), \"My stuff\") self.assertEqual(overload.safety(), \"Safe!\") self.assertEqual(overload.safety(), m.safety())","title":"Overloaded Functions"},{"location":"python/examples/#overriding-virtual-functions-in-python","text":"#include <string> class Animal { public: virtual ~Animal() { } virtual std::string sound(int n_times, bool grumpy) = 0; }; class Dog : public Animal { public: std::string sound(int n_times, bool grumpy) override { if (grumpy) { return \"No.\"; } std::string result; for (int i = 0; i < n_times; ++i) { result += \"woof! \"; } return result; } }; std::string call_sound(Animal *animal) { return animal->sound(3, false); } fido = m.Dog() grumpy = True # Overloaded function in C++ self.assertEqual(fido.sound(1, not grumpy), \"woof! \") # Polymorphic function in C++ self.assertEqual(m.call_sound(fido), \"woof! woof! woof! \") # Inherit from virtual C++ classes in python class Cat(m.Animal): # Override C++ function def sound(self, n_times, grumpy): return \"No.\" if grumpy else \"meow! \" * n_times whiskers = Cat() # Overloaded C++ function in python self.assertEqual(whiskers.sound(1, grumpy), \"No.\") self.assertEqual(whiskers.sound(1, not grumpy), \"meow! \") # Polymorphic function in C++ called with python object self.assertEqual(m.call_sound(whiskers), \"meow! meow! meow! \")","title":"Overriding virtual functions in python"},{"location":"python/examples/#overriding-virtual-in-python","text":"#include <string> class Animal { public: virtual ~Animal() { } virtual std::string sound(int n_times, bool grumpy) = 0; }; class Dog : public Animal { public: std::string sound(int n_times, bool grumpy) override { if (grumpy) { return \"No.\"; } std::string result; for (int i = 0; i < n_times; ++i) { result += \"woof! \"; } return result; } }; std::string call_sound(Animal *animal) { return animal->sound(3, false); } fido = m.Dog() grumpy = True # Overloaded function in C++ self.assertEqual(fido.sound(1, grumpy), \"No.\") self.assertEqual(fido.sound(1, not grumpy), \"woof! \") # Polymorphic function in C++ self.assertEqual(m.call_sound(fido), \"woof! woof! woof! \") # Inherit from virtual C++ classes in python class Cat(m.Animal): # Override C++ function def sound(self, n_times, grumpy): return \"No.\" if grumpy else \"meow! \" * n_times whiskers = Cat() # Overloaded C++ function in python self.assertEqual(whiskers.sound(1, grumpy), \"No.\") self.assertEqual(whiskers.sound(1, not grumpy), \"meow! \") # Polymorphic function in C++ called with python object self.assertEqual(m.call_sound(whiskers), \"meow! meow! meow! \")","title":"Overriding virtual in python"},{"location":"python/examples/#simple-inheritence","text":"#include <string> struct Pet { Pet(const std::string &name) : name(name) { } std::string name; }; struct Dog : public Pet { Dog(const std::string &name) : Pet(name) { } std::string bark() const { return \"woof!\"; } }; fido = m.Dog(\"Fido\") # Inherits public properties self.assertEqual(fido.name, \"Fido\") # But has its new functions self.assertEqual(fido.bark(), \"woof!\")","title":"Simple inheritence"},{"location":"python/examples/#smart-pointers","text":"#include <memory> struct Example { int m_hi = 5; }; struct ExampleShared { int m_hi = 10; }; std::unique_ptr<Example> create_unique() { return std::make_unique<Example>(); } std::shared_ptr<ExampleShared> create_shared() { return std::make_shared<ExampleShared>(); } # std::unique_ptr acts as a normal value # Note that passing a std::unique_ptr as an argument gives an error # See https://pybind11.readthedocs.io/en/stable/advanced/smart_ptrs.html u = m.create_unique() self.assertEqual(u.m_hi, 5) # std::shared_ptr acts as a normal value s = m.create_shared() self.assertEqual(s.m_hi, 10)","title":"Smart Pointers"},{"location":"python/examples/#stdarray","text":"#include <array> #include <string> class WithMember { public: explicit WithMember(std::array<std::string, 2> s) : m_s(s) {} std::array<std::string, 2> getS() { return m_s; } private: std::array<std::string, 2> m_s; }; class WithFunction { public: int sum(std::array<int, 5> v) { int s = 0; for (auto i : v) { s += i; } return s; } }; # std::array translates to a normal array in python my_array = [\"hi\", \"ho\"] with_member = m.WithMember(my_array) self.assertEqual(with_member.getS(), my_array) with_function = m.WithFunction() self.assertEqual(with_function.sum([1, 2, 3, 4, 5]), 15) # It still corresponds to a fixed amount of elements for incompatible_array in [[\"too many\", \"too many\", \"too many\"], [\"too few\"]]: with self.assertRaises(TypeError) as error_context: with_member = m.WithMember(incompatible_array) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \" + str(error_context.exception.args[0]), ) self.assertTrue( \"Invoked with: \" + str(incompatible_array) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \" + str(error_context.exception.args[0]), )","title":"std::array"},{"location":"python/examples/#stdcomplex","text":"#include <complex> using namespace std::complex_literals; std::complex<int> i() { return 5; } std::complex<double> d() { return 1. + 2i; } std::complex<float> f() { return 0.f + 5if; } std::complex<double> r(std::complex<double> d) { return d; } # std::complex translates to a complex in python i = m.i() self.assertEqual(i.real, 5) self.assertEqual(i.imag, 0) d = m.d() self.assertEqual(d.real, 1) self.assertEqual(d.imag, 2) f = m.f() self.assertEqual(f.real, 0) self.assertEqual(f.imag, 5) # Using python builtin complex class r = m.r(complex(1, 2)) self.assertEqual(r.real, 1) self.assertEqual(r.imag, 2)","title":"std::complex"},{"location":"python/examples/#stddeque","text":"#include <string> #include <deque> class WithMember { public: explicit WithMember(std::deque<std::string> s) : m_s(s) {} std::deque<std::string> getS() { return m_s; } private: std::deque<std::string> m_s; }; class WithFunction { public: int sum(std::deque<int> v) { int s = 0; for (auto i : v) { s += i; } return s; } }; # std::deque translates to a normal array in python my_array = [\"hi\", \"ho\"] with_member = m.WithMember(my_array) self.assertEqual(with_member.getS(), my_array) with_function = m.WithFunction() self.assertEqual(with_function.sum([1, 2, 3]), 6)","title":"std::deque"},{"location":"python/examples/#stdfilesystempath","text":"#include <filesystem> #include <vector> std::filesystem::path takingPath(std::filesystem::path p) { return p; } std::string toString(std::filesystem::path p) { return p.string(); } std::filesystem::path joinPaths(std::vector<std::filesystem::path> arrayToSum) { std::filesystem::path sum; for (auto f : arrayToSum) { sum /= f; } return sum; } # std::filesystem::path translates to pathlib.Path in python from pathlib import Path p0 = Path(\"Hello\") result0 = m.takingPath(p0) self.assertEqual(result0, p0) p1 = Path(\"Something\") toString = m.toString(p1) self.assertEqual(toString, p1.name) result1 = m.joinPaths([p0, p1]) self.assertEqual(result1, p0 / p1)","title":"std::filesystem::path"},{"location":"python/examples/#stdfunction","text":"#include <functional> #include <vector> double takingFunction(std::function<double(int)> callMe) { return callMe(5); } std::function<int(int)> returnFunction(const std::function<int(int)> &f) { return [f](int i) { return f(i) + 1; }; } int accumulateArrayOfFunctions(std::vector<std::function<int()>> arrayToSum) { int sum = 0; for (auto f : arrayToSum) { sum += f(); } return sum; } def callback(i): return i # You can send a python function as a C++ callback result0 = m.takingFunction(callback) self.assertEqual(result0, 5.0) # Or in the other direction inc_by_one = m.returnFunction(callback) self.assertEqual(inc_by_one(5), 6) def fiver(): return 5 # Or a vector of functions result1 = m.accumulateArrayOfFunctions([fiver, fiver]) self.assertEqual(result1, 10)","title":"std::function"},{"location":"python/examples/#stdlist","text":"#include <string> #include <list> class WithMember { public: explicit WithMember(std::list<std::string> s) : m_s(s) {} std::list<std::string> getS() { return m_s; } private: std::list<std::string> m_s; }; class WithFunction { public: int sum(std::list<int> v) { int s = 0; for (auto i : v) { s += i; } return s; } }; # std::list translates to a normal array in python my_array = [\"hi\", \"ho\"] with_member = m.WithMember(my_array) self.assertEqual(with_member.getS(), my_array) with_function = m.WithFunction() self.assertEqual(with_function.sum([1, 2, 3]), 6)","title":"std::list"},{"location":"python/examples/#stdmap","text":"#include <map> #include <string> class MyClass { public: explicit MyClass(std::map<std::string, int> s) : m_s(s) {} std::map<std::string, int> getS() { return m_s; } std::string getValue(std::map<int, std::string> const& m, int key) { auto it = m.find(key); if (it != m.end()) { return it->second; } return \"\"; } private: std::map<std::string, int> m_s; }; # std::map translates to a normal dictionary in python my_map = {\"hi\": 4, \"ho\": 5} c = m.MyClass(my_map) self.assertEqual(c.getS(), my_map) # The maps are typed on the C++ side for incopatible_map in [{\"key\": \"value\"}, {5: 2}]: with self.assertRaises(TypeError) as error_context: c = m.MyClass(incopatible_map) c.getValue(incopatible_map, 5) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible function arguments\" in error_context.exception.args[0] or \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \\n\\t\" + str(error_context.exception.args[0]), ) self.assertTrue( str(incopatible_map) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \\n\\t\" + str(error_context.exception.args[0]), )","title":"std::map"},{"location":"python/examples/#stdoptional","text":"#include <optional> #include <string> class WithMember { public: explicit WithMember(std::optional<std::string> s) : m_s(s) {} std::optional<std::string> getS() { return m_s; } private: std::optional<std::string> m_s; }; class WithFunction { public: std::optional<int> getNullopt() { return std::nullopt; } }; # std::optional is either the value or None in python greeting = \"hello\" with_member = m.WithMember(greeting) self.assertEqual(with_member.getS(), greeting) with_function = m.WithFunction() self.assertEqual(with_function.getNullopt(), None)","title":"std::optional"},{"location":"python/examples/#stdpair","text":"#include <string> class MyClass { public: explicit MyClass(std::pair<std::string, int> s) : m_s(s) {} std::pair<std::string, int> getS() { return m_s; } private: std::pair<std::string, int> m_s; }; class WithFunction { public: int sum(std::pair<int, int> v) { return v.first + v.second; } }; # Converts to a tuple, but is convertible from array aswell my_array = [\"hi\", 4] for t in [my_array, tuple(my_array)]: with_member = m.MyClass(t) self.assertEqual(with_member.getS(), tuple(t)) with_function = m.WithFunction() self.assertEqual(with_function.sum((1, 2)), 3)","title":"std::pair"},{"location":"python/examples/#stdset","text":"#include <set> #include <string> class MyClass { public: explicit MyClass(std::set<std::string> s) : m_s(s) {} std::set<std::string> getS() { return m_s; } int getValue(std::set<int> const& m, int key) { auto it = m.find(key); if (it != m.end()) { return *it; } return -1; } private: std::set<std::string> m_s; }; # std::set translates to a normal array or a set in python mySet = {\"hi\", \"this is a set\"} c = m.MyClass(mySet) self.assertEqual(c.getS(), mySet) self.assertEqual(c.getValue({1, 2, 3}, 3), 3) self.assertEqual(c.getValue({1, 2, 3}, 4), -1) # Test set of the wrong type for incompatibleset in [{\"key\": \"value\"}, (5, 2)]: with self.assertRaises(TypeError) as error_context: c = m.MyClass(incompatibleset) c.getValue(incompatibleset, 5) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible function arguments\" in error_context.exception.args[0] or \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \\n\\t\" + str(error_context.exception.args[0]), ) self.assertTrue( str(incompatibleset) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \\n\\t\" + str(error_context.exception.args[0]), )","title":"std::set"},{"location":"python/examples/#stdtuple","text":"#include <string> #include <tuple> class MyClass { public: explicit MyClass(std::tuple<std::string, int> s) : m_s(s) {} std::tuple<std::string, int> getS() { return m_s; } std::tuple<std::string, int> m_s; }; class WithFunction { public: double sum(std::tuple<int, int, float, double> t) { return std::get<0>(t) + std::get<1>(t) + std::get<2>(t) + std::get<3>(t); } }; # Converts to a tuple, but is convertible from array aswell my_array = [\"hi\", 4] for t in [my_array, tuple(my_array)]: with_member = m.MyClass(t) self.assertEqual(with_member.getS(), tuple(t)) with_function = m.WithFunction() self.assertAlmostEqual(with_function.sum((1, 2, 3.3, 2.0)), 8.3, delta=0.0001)","title":"std::tuple"},{"location":"python/examples/#stdunordered_map","text":"#include <string> #include <unordered_map> class MyClass { public: explicit MyClass(std::unordered_map<std::string, int> s) : m_s(s) {} std::unordered_map<std::string, int> getS() { return m_s; } std::string getValue(std::unordered_map<int, std::string> const& m, int key) { auto it = m.find(key); if (it != m.end()) { return it->second; } return \"\"; } private: std::unordered_map<std::string, int> m_s; }; # std::unordered_map translates to a normal dictionary in python myunordered_map = {\"hi\": 4, \"ho\": 5} c = m.MyClass(myunordered_map) self.assertEqual(c.getS(), myunordered_map) # Test unordered_map of the wrong type for incompatible_map in [{\"key\": \"value\"}, {5: 2}]: with self.assertRaises(TypeError) as error_context: c = m.MyClass(incompatible_map) c.getValue(incompatible_map, 5) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible function arguments\" in error_context.exception.args[0] or \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \\n\\t\" + str(error_context.exception.args[0]), ) self.assertTrue( str(incompatible_map) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \\n\\t\" + str(error_context.exception.args[0]), )","title":"std::unordered_map"},{"location":"python/examples/#stdunordered_set","text":"#include <string> #include <unordered_set> class MyClass { public: explicit MyClass(std::unordered_set<std::string> s) : m_s(s) {} std::unordered_set<std::string> getS() { return m_s; } int getValue(std::unordered_set<int> const& m, int key) { auto it = m.find(key); if (it != m.end()) { return *it; } return -1; } private: std::unordered_set<std::string> m_s; }; # std::unordered_set translates to a normal array or a set in python my_unordered_set = {\"hi\", \"this is a unordered_set\"} c = m.MyClass(my_unordered_set) self.assertEqual(c.getS(), my_unordered_set) self.assertEqual(c.getValue({1, 2, 3}, 3), 3) self.assertEqual(c.getValue({1, 2, 3}, 4), -1) # Test unordered_set of the wrong type for incompatible_set in [{\"key\": \"value\"}, (5, 2)]: with self.assertRaises(TypeError) as error_context: c = m.MyClass(incompatible_set) c.getValue(incompatible_set, 5) self.assertEqual(len(error_context.exception.args), 1) self.assertTrue( \"incompatible function arguments\" in error_context.exception.args[0] or \"incompatible constructor arguments\" in error_context.exception.args[0], \"Error msg does not mention incompatible arguments: \\n\\t\" + str(error_context.exception.args[0]), ) self.assertTrue( str(incompatible_set) in error_context.exception.args[0], \"Error msg does not mention the given arguments: \\n\\t\" + str(error_context.exception.args[0]), )","title":"std::unordered_set"},{"location":"python/examples/#stdvalarray","text":"#include <valarray> std::valarray<int> get() { return {1, 2, 3}; } v = m.get() self.assertEqual(v, [1, 2, 3])","title":"std::valarray"},{"location":"python/examples/#stdvariant","text":"#include <string> #include <variant> class WithMember { public: explicit WithMember(std::variant<int, bool> s) : m_s(s) {} std::variant<int, bool> getS() { return m_s; } private: std::variant<int, bool> m_s; }; class WithFunction { public: std::variant<int, std::string, bool> getFive() { return 5; } std::variant<int, std::string, bool> getHello() { return std::string(\"Hello\"); } std::variant<int, std::string, bool> getTrue() { return true; } }; # std::variant translates to one of the values in python number = 6 withNumber = m.WithMember(number) self.assertEqual(withNumber.getS(), number) withBool = m.WithMember(True) self.assertEqual(withBool.getS(), True) with_function = m.WithFunction() self.assertEqual(with_function.getFive(), 5) self.assertEqual(with_function.getHello(), \"Hello\") self.assertEqual(with_function.getTrue(), True)","title":"std::variant"},{"location":"python/examples/#stdvector","text":"#include <string> #include <vector> class WithMember { public: explicit WithMember(std::vector<std::string> s) : m_s(s) {} std::vector<std::string> getS() { return m_s; } private: std::vector<std::string> m_s; }; class WithFunction { public: int sum(std::vector<int> v) { int s = 0; for (auto i : v) { s += i; } return s; } }; # std::vector translates to a normal array in python my_array = [\"hi\", \"ho\"] with_member = m.WithMember(my_array) self.assertEqual(with_member.getS(), my_array) with_function = m.WithFunction() self.assertEqual(with_function.sum([1, 2, 3]), 6)","title":"std::vector"},{"location":"python/examples/#templates","text":"#include <array> #include <map> #include <string> #include <vector> template <typename T> T getSomething(T something) { return something; } template std::string getSomething(std::string something); template int getSomething(int); template std::vector<std::string> getSomething(std::vector<std::string>); template <typename T> class MyClass { public: T myFun(T type) { return type; } }; template class MyClass<int>; template class MyClass<std::map<char, std::vector<int>>>; template class MyClass<std::array<int, 3>>; # getSomething<std::string> hi = m.getSomething(\"hi\") self.assertEqual(hi, \"hi\") # getSomething<int> five = m.getSomething(5) self.assertEqual(five, 5) # getSomething<std::vector<std::string>> l = m.getSomething([\"hi\"]) self.assertEqual(l, [\"hi\"]) # MyClass<int> my_class_int = m.MyClass_int() self.assertEqual(my_class_int.myFun(25), 25) # MyClass<std::map<char, std::vector<int>>> my_class_map = m.MyClass_map_char_vector_int() self.assertEqual(my_class_map.myFun({'h': [1]}), {'h': [1]}) # MyClass<std::array<int, 3>> my_class_array = m.MyClass_array_int_3() self.assertEqual(my_class_array.myFun([1, 2, 3]), [1, 2, 3])","title":"Templates"},{"location":"python/quickstart/","text":"Python with Tolc In order for C++ to be called from python there has to be an interface level. tolc generates this level from your already written C++ interface. To be as close to what an engineer would have written, tolc generates human readable pybind11 . This is then compiled to a CPython library that the python interpreter can understand. Using a C++ library from python This is a quick guide to using a C++ library (here called MyLib ) from python . We will: Download and use Tolc Use the resulting CPython library from python The following works on all supported platforms. On all platforms you need git available in your path . Commands that should be run from a terminal starts with $ , while comments starts with # . Downloading and Using Tolc Just add the following in a CMakeLists.txt below where the library you intend to use from javascript is defined: # Download Tolc # Can be [\"latest\", \"v0.2.0\", ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) tolc_create_bindings( TARGET MyLib LANGUAGE python OUTPUT python-bindings ) Assuming your library is called MyLib , and the bindings should be generated to the directory python-bindings . Now you can configure your project as normal (in Visual Studio, this is typically done automatically on save): $ cmake -S. -Bbuild And finally build it: $ cmake --build build This will produce a CPython library under build/tolc (with MSVC it will be under for example build/tolc/Debug ), and you can use it as: # With MSVC build\\tolc\\Debug $ cd build/tolc $ python >>> import MyLib If you want to see what more is supported you can take a look at the Examples section .","title":"Quickstart"},{"location":"python/quickstart/#python-with-tolc","text":"In order for C++ to be called from python there has to be an interface level. tolc generates this level from your already written C++ interface. To be as close to what an engineer would have written, tolc generates human readable pybind11 . This is then compiled to a CPython library that the python interpreter can understand.","title":"Python with Tolc"},{"location":"python/quickstart/#using-a-c-library-from-python","text":"This is a quick guide to using a C++ library (here called MyLib ) from python . We will: Download and use Tolc Use the resulting CPython library from python The following works on all supported platforms. On all platforms you need git available in your path . Commands that should be run from a terminal starts with $ , while comments starts with # .","title":"Using a C++ library from python"},{"location":"python/quickstart/#downloading-and-using-tolc","text":"Just add the following in a CMakeLists.txt below where the library you intend to use from javascript is defined: # Download Tolc # Can be [\"latest\", \"v0.2.0\", ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) tolc_create_bindings( TARGET MyLib LANGUAGE python OUTPUT python-bindings ) Assuming your library is called MyLib , and the bindings should be generated to the directory python-bindings . Now you can configure your project as normal (in Visual Studio, this is typically done automatically on save): $ cmake -S. -Bbuild And finally build it: $ cmake --build build This will produce a CPython library under build/tolc (with MSVC it will be under for example build/tolc/Debug ), and you can use it as: # With MSVC build\\tolc\\Debug $ cd build/tolc $ python >>> import MyLib If you want to see what more is supported you can take a look at the Examples section .","title":"Downloading and Using Tolc"},{"location":"python/template_naming_convention/","text":"Template Naming Convention When creating bindings for a templated class tolc will choose a name based on the template parameters. For example: template <typename T> class Example { public: T f(T type) { return type; } }; template class Example<int>; The specialized class Example<int> will be available from python as Example_int : import MyLib example = MyLib.Example_int() # Prints 5 print(example.f(5)) Multiple template parameters are separated with an underscore (_). The names are meant to be as predictable as possible. The rules are: std:: is removed from any standard library type. _ is removed from any standard library type. User defined types are left untouched (i.e. the class MyNamespace::MyClass will result in appending MyClass ). Type to string conversions C++ type Resulting name std::array array std::complex complex std::deque deque std::filesystem::path path std::forward_list forwardlist std::function function std::list list std::map map std::multimap multimap std::multiset multiset std::optional optional std::pair pair std::priority_queue priorityqueue std::queue queue std::set set std::shared_ptr sharedptr std::stack stack std::tuple tuple std::unique_ptr uniqueptr std::unordered_map unorderedmap std::unordered_multimap unorderedmultimap std::unordered_multiset unorderedmultiset std::unordered_set unorderedset std::valarray valarray std::variant variant std::vector vector bool bool char char char16_t char16t char32_t char32t double double float float int int Integral Integral literal* long double longdouble long int longint long long int longlongint short int shortint signed char signedchar string string string_view stringview unsigned char unsignedchar unsigned int unsignedint unsigned long int unsignedlongint unsigned long long int unsignedlonglongint unsigned short int unsignedshortint wchar_t wchart * For example the 3 in MyClass<std::array<int, 3>> results in MyClass_array_int_3 .","title":"Template Naming Convention"},{"location":"python/template_naming_convention/#template-naming-convention","text":"When creating bindings for a templated class tolc will choose a name based on the template parameters. For example: template <typename T> class Example { public: T f(T type) { return type; } }; template class Example<int>; The specialized class Example<int> will be available from python as Example_int : import MyLib example = MyLib.Example_int() # Prints 5 print(example.f(5)) Multiple template parameters are separated with an underscore (_). The names are meant to be as predictable as possible. The rules are: std:: is removed from any standard library type. _ is removed from any standard library type. User defined types are left untouched (i.e. the class MyNamespace::MyClass will result in appending MyClass ).","title":"Template Naming Convention"},{"location":"python/template_naming_convention/#type-to-string-conversions","text":"C++ type Resulting name std::array array std::complex complex std::deque deque std::filesystem::path path std::forward_list forwardlist std::function function std::list list std::map map std::multimap multimap std::multiset multiset std::optional optional std::pair pair std::priority_queue priorityqueue std::queue queue std::set set std::shared_ptr sharedptr std::stack stack std::tuple tuple std::unique_ptr uniqueptr std::unordered_map unorderedmap std::unordered_multimap unorderedmultimap std::unordered_multiset unorderedmultiset std::unordered_set unorderedset std::valarray valarray std::variant variant std::vector vector bool bool char char char16_t char16t char32_t char32t double double float float int int Integral Integral literal* long double longdouble long int longint long long int longlongint short int shortint signed char signedchar string string string_view stringview unsigned char unsignedchar unsigned int unsignedint unsigned long int unsignedlongint unsigned long long int unsignedlonglongint unsigned short int unsignedshortint wchar_t wchart * For example the 3 in MyClass<std::array<int, 3>> results in MyClass_array_int_3 .","title":"Type to string conversions"},{"location":"webassembly/conversions/","text":"C++ to WebAssembly conversions This page shows what is automatically translated and to what. On the left is the C++ and to the right what the corresponding interface in javascript will be. Not converted means there will be no automatic translation to a corresponding javascript object. Note that any restriction this poses only applies to the public interface of your code (e.g. your public headers). Conversion tables C++ WebAssembly translation Namespace Object namespace Nested namespace Nested object namespace Class Class Public function Class function Private function Not converted Virtual function Overridable function Static member function Static class function Static member variable Static member variable Public const member variable Read only property Public non const member variable Read write property Private member variable Not converted Global variable Module variable Global static variable Module variable Free function Module function Overloaded function Module function* Enum Enum Scoped enum Enum Templated class/function Not converted** Specialized class template Class*** Specialized function template Function**** * Changes the name of the function based on the arguments to avoid clashes. ** No direct translation to javascript . Will not emit warning. *** The naming convention for these classes can be found under the Template Naming Convention page . **** Functions with different template arguments will behave as overloaded functions. C++ Standard library class WebAssembly translation std::array array std::complex ??? std::deque ??? std::filesystem::path ??? std::forward_list Not converted std::function ??? std::list ??? std::map Map Object* std::multimap Not converted std::multiset Not converted std::optional ??? std::pair array std::priority_queue Not converted std::queue Not converted std::set ??? std::shared_ptr ??? std::stack Not converted std::tuple ??? std::unique_ptr Value** std::shared_ptr Value std::unordered_map ??? std::unordered_multimap Not converted std::unordered_multiset Not converted std::unordered_set ??? std::valarray ??? std::variant ??? std::vector Vector Object*** * Converted via the register_map function (behaves like an Object in javascript ). ** Note that arguments of type unique_ptr<T> are not supported. For more info see here . *** Converted via the register_vector function (behaves like an Object in javascript ). C++ builtin type WebAssembly translation bool true char Number char16_t Number char32_t Number double Number float Number int Number int8_t Number int16_t Number int32_t Number int64_t Number long double Number long int Number long long int Number short int Number signed char Number string ArrayBuffer, Uint8Array, Uint8ClampedArray, Int8Array, or String string_view String* uint8_t Number uint16_t Number uint32_t Number uint64_t Number unsigned char Number unsigned int Number unsigned long int Number unsigned long long int Number unsigned short int Number wchar_t Number * Only works for globals (see examples )","title":"Conversions"},{"location":"webassembly/conversions/#c-to-webassembly-conversions","text":"This page shows what is automatically translated and to what. On the left is the C++ and to the right what the corresponding interface in javascript will be. Not converted means there will be no automatic translation to a corresponding javascript object. Note that any restriction this poses only applies to the public interface of your code (e.g. your public headers).","title":"C++ to WebAssembly conversions"},{"location":"webassembly/conversions/#conversion-tables","text":"C++ WebAssembly translation Namespace Object namespace Nested namespace Nested object namespace Class Class Public function Class function Private function Not converted Virtual function Overridable function Static member function Static class function Static member variable Static member variable Public const member variable Read only property Public non const member variable Read write property Private member variable Not converted Global variable Module variable Global static variable Module variable Free function Module function Overloaded function Module function* Enum Enum Scoped enum Enum Templated class/function Not converted** Specialized class template Class*** Specialized function template Function**** * Changes the name of the function based on the arguments to avoid clashes. ** No direct translation to javascript . Will not emit warning. *** The naming convention for these classes can be found under the Template Naming Convention page . **** Functions with different template arguments will behave as overloaded functions. C++ Standard library class WebAssembly translation std::array array std::complex ??? std::deque ??? std::filesystem::path ??? std::forward_list Not converted std::function ??? std::list ??? std::map Map Object* std::multimap Not converted std::multiset Not converted std::optional ??? std::pair array std::priority_queue Not converted std::queue Not converted std::set ??? std::shared_ptr ??? std::stack Not converted std::tuple ??? std::unique_ptr Value** std::shared_ptr Value std::unordered_map ??? std::unordered_multimap Not converted std::unordered_multiset Not converted std::unordered_set ??? std::valarray ??? std::variant ??? std::vector Vector Object*** * Converted via the register_map function (behaves like an Object in javascript ). ** Note that arguments of type unique_ptr<T> are not supported. For more info see here . *** Converted via the register_vector function (behaves like an Object in javascript ). C++ builtin type WebAssembly translation bool true char Number char16_t Number char32_t Number double Number float Number int Number int8_t Number int16_t Number int32_t Number int64_t Number long double Number long int Number long long int Number short int Number signed char Number string ArrayBuffer, Uint8Array, Uint8ClampedArray, Int8Array, or String string_view String* uint8_t Number uint16_t Number uint32_t Number uint64_t Number unsigned char Number unsigned int Number unsigned long int Number unsigned long long int Number unsigned short int Number wchar_t Number * Only works for globals (see examples )","title":"Conversion tables"},{"location":"webassembly/examples/","text":"Examples Each example is taken from the test suite for Tolc and, given that you use the latest version, you can expect them all to work. To use WebAssembly from javascript , one has to load it in asynchronously. When using Tolc this is done with a Promise on the javascript side. Each library named MyLib exports a Promise called loadMyLib , in every test the name is simply m for brevity. All tests use jest , and the javascript test boiler plate is omitted: const loadm = require('./build/m'); test('Tolc Test', () => { loadm().then(m => { // The actual javascript example body goes here expect(m.sayTen()).toBe(10); }); }); Classes #include <string> #include <string_view> class WithConstructor { public: explicit WithConstructor(std::string s) : m_s(s) {} // There is a separate .cpp file containing // int const WithConstructor::i; // To initialize i static int const i = 5; std::string getS() { return m_s; } static int getStatic() { return 55; } private: std::string m_s; }; struct WithMembers { int const i = 5; std::string s = \"hello\"; }; class WithFunction { public: int add(int i, int j) { return i + j; } }; class WithPrivateFunction { double multiply(double i, double j) { return i * j; } }; namespace MyNamespace { struct Nested { int const i = 42; }; } struct WithEnum { enum class Instrument { Guitarr, Flute }; Instrument i = Instrument::Flute; }; // Statics are available without instantiation // Static function expect(m.WithConstructor.getStatic()).toBe(55); // Static variable expect(m.WithConstructor.i).toBe(5); const withConstructor = new m.WithConstructor(\"Hello\"); expect(withConstructor.getS()).toBe(\"Hello\"); // Classes need to be deleted manually withConstructor.delete(); // Const properties are read-only const withMembers = new m.WithMembers(); expect(withMembers.i).toBe(5); try { withMembers.i = 10; expect(true).toBe(false); } catch (err) { expect(err.toString()).toMatch(/BindingError: WithMembers.i is a read-only property/i); } expect(withMembers.s).toBe(\"hello\"); withMembers.delete(); // Public functions are available const withFunction = new m.WithFunction(); expect(withFunction.add(5, 10)).toBe(15); withFunction.delete(); // Cannot access private functions const withPrivateFunction = new m.WithPrivateFunction(); try { withPrivateFunction.multiply(5, 10); expect(true).toBe(false); } catch (err) { expect(err.toString()).toMatch(/TypeError: withPrivateFunction.multiply is not a function/i); } withPrivateFunction.delete(); // Classes can be found under their namespace const nested = new m.MyNamespace.Nested(); expect(nested.i).toBe(42); nested.delete(); // Ok to nest Enums within classes const withEnum = new m.WithEnum(); expect(withEnum.i).toBe(m.WithEnum.Instrument.Flute); withEnum.delete(); Enums enum Unscoped { Under, Uboat, }; enum class Scoped { Sacred, Snail, }; class EnumTest { public: enum class Inside { One, Two }; explicit EnumTest(Scoped s) : memberEnum(s), inside(Inside::One) {}; Inside inside; Scoped memberEnum; }; Unscoped echo(Unscoped s) { return s; } namespace MyNamespace { enum class Color { Red, Green, Blue }; struct Carrier { enum class Translator { Tolc }; }; } // Can be passed as arguments const snail = m.Scoped.Snail; const enumTest = new m.EnumTest(snail); expect(enumTest.memberEnum).toBe(snail); // Nested enums within classes expect(enumTest.inside).toBe(m.EnumTest.Inside.One); enumTest.delete(); // Unscoped enums work exactly the same const uboat = m.Unscoped.Uboat; expect(m.echo(uboat)).toBe(uboat); // Nested enums inside namespaces const green = m.MyNamespace.Color.Green; expect(green).toBe(m.MyNamespace.Color.Green); // Nested enums inside namespaces inside structs const company = m.MyNamespace.Carrier.Translator.Tolc; expect(company).toBe(m.MyNamespace.Carrier.Translator.Tolc); Functions #include <string> int sayTen() { return 10; } std::string giveBack(std::string const& s) { return s; } namespace MyNamespace { int add(int x, int y) { return x + y; } namespace Nested { int increase(int x) { return x + 1; } } } expect(m.sayTen()).toBe(10); expect(m.giveBack(\"hello\")).toBe(\"hello\"); // Nested functions are under their respective namespace expect(m.MyNamespace.add(1, 2)).toBe(3); expect(m.MyNamespace.Nested.increase(2)).toBe(3); Global Variables #include <string_view> int const i = 0; double const d = 55; std::string_view const stringView = \"Hello world\"; const char* charPtr = \"Hello world\"; namespace MyNamespace { int const i = 5; } expect(m.i).toBe(0); expect(m.d).toBe(55); // Global strings of type std::string_view and const char* are converted // Globals of type std::string has an open issue: // https://github.com/emscripten-core/emscripten/issues/16275 expect(m.stringView).toBe(\"Hello world\"); expect(m.charPtr).toBe(\"Hello world\"); // Globals within namespaces work expect(m.MyNamespace.i).toBe(5); Namespaces #include <string> namespace MyLib { int complexFunction() { return 5; } namespace We { namespace Are { namespace Going { namespace Pretty { namespace Deep { std::string meaningOfLife() { return \"42\"; } } } } } } } expect(m.MyLib.complexFunction()).toBe(5); // Namespaces can be nested arbitrarily expect(m.MyLib.We.Are.Going.Pretty.Deep.meaningOfLife()).toBe('42'); Overriding virtual in javascript #include <string> class Animal { public: virtual ~Animal() { } virtual std::string sound(int n_times, bool grumpy) = 0; }; class Dog : public Animal { public: std::string sound(int n_times, bool grumpy) override { if (grumpy) { return \"No.\"; } std::string result; for (int i = 0; i < n_times; ++i) { result += \"woof! \"; } return result; } }; std::string call_sound(Animal *animal) { return animal->sound(3, false); } const fido = new m.Dog(); const grumpy = true; // Overloaded function in C++ expect(fido.sound(1, grumpy)).toBe(\"No.\") expect(fido.sound(1, !grumpy)).toBe(\"woof! \") // Polymorphic function in C++ expect(m.call_sound(fido)).toBe(\"woof! woof! woof! \") fido.delete(); // Inherit from virtual C++ classes in javascript const Cat = m.Animal.extend(\"Animal\", { // Override C++ function sound: function(n_times, grumpy) { return grumpy ? \"No.\" : \"meow! \".repeat(n_times); }, }); const whiskers = new Cat(); // Overloaded C++ function in javascript expect(whiskers.sound(1, grumpy)).toBe(\"No.\") expect(whiskers.sound(1, !grumpy)).toBe(\"meow! \") // Polymorphic function in C++ called with javascript object // Automatic downcasting expect(m.call_sound(whiskers)).toBe(\"meow! meow! meow! \") whiskers.delete(); // Another way is to just provide what is needed // to implement the Animal interface const tiger = m.Animal.implement({ // Put only the functions you want to implement here sound: function(n_times, grumpy) { return grumpy ? \"No.\" : \"roar! \".repeat(n_times); }, }); expect(tiger.sound(1, grumpy)).toBe(\"No.\") expect(tiger.sound(1, !grumpy)).toBe(\"roar! \") // Automatic downcasting works the same expect(m.call_sound(tiger)).toBe(\"roar! roar! roar! \") tiger.delete(); Simple inheritence #include <string> struct Pet { Pet(const std::string &name) : name(name) { } std::string name; }; struct Dog : public Pet { Dog(const std::string &name) : Pet(name) { } std::string bark() const { return \"woof!\"; } }; const fido = new m.Dog(\"Fido\"); // Inherits public properties expect(fido.name).toBe(\"Fido\") // But has its new functions expect(fido.bark()).toBe(\"woof!\") Smart Pointers #include <memory> struct Example { int m_value = 5; }; struct ExampleShared { int m_value = 10; }; std::unique_ptr<Example> create_unique() { return std::make_unique<Example>(); } std::shared_ptr<ExampleShared> create_shared() { return std::make_shared<ExampleShared>(); } // Note: Embind only supports *return*-values of std::unique_ptr // An argument of type std::unique_ptr<T> will return in an error message // std::unique_ptr just corresponds to the value u = m.create_unique(); expect(u.m_value).toBe(5); u.delete(); // std::shared_ptr also just corresponds to the value s = m.create_shared(); expect(s.m_value).toBe(10); s.delete(); std::array #include <array> #include <string> std::array<double, 3> getData3() { return {0.0, 1.0, 2.0}; } // Multiple array types at the same time std::array<int, 2> getData2() { return {0, 1}; } const data3 = m.getData3(); // It's just a normal JS array expect(data3.length).toBe(3); expect(data3).toStrictEqual([0, 1, 2]); const data2 = m.getData2(); expect(data2.length).toBe(2); expect(data2).toStrictEqual([0, 1]); std::map #include <map> #include <string> std::map<int, std::string> getData() { std::map<int, std::string> m; m.insert({10, \"hello\"}); return m; } const data = m.getData(); expect(data.size()).toBe(1); expect(data.get(10)).toBe(\"hello\"); data.set(50, \"Stuff\"); expect(data.size()).toBe(2); expect(data.get(50)).toBe(\"Stuff\"); std::pair #include <string> class MyClass { public: explicit MyClass(std::pair<std::string, int> s) : m_s(s) {} std::pair<std::string, int> getS() { return m_s; } private: std::pair<std::string, int> m_s; }; class WithFunction { public: int sum(std::pair<int, int> v) { return v.first + v.second; } }; // On the javascript side, std::pair<std::string, int> is a basic array const myArray = [\"hi\", 4]; withMember = new m.MyClass(myArray); expect(withMember.getS()).toStrictEqual(myArray); withMember.delete(); const withFunction = new m.WithFunction() expect(withFunction.sum([1, 2])).toBe(3) withFunction.delete(); std::tuple #include <string> #include <tuple> class MyClass { public: explicit MyClass(std::tuple<std::string, int> _tuple) : m_tuple(_tuple) {} std::tuple<std::string, int> getTuple() { return m_tuple; } std::tuple<std::string, int> m_tuple; }; class WithFunction { public: double sum(std::tuple<int, int, float, double> t) { return std::get<0>(t) + std::get<1>(t) + std::get<2>(t) + std::get<3>(t); } }; // Tuple converts from javascript array const myArray = [\"Hello World\", 42]; const myClass = new m.MyClass(myArray); expect(myClass.getTuple()).toStrictEqual(myArray); // The array still need to match the underlying std::tuple structure try { // m_tuple is public myClass.m_tuple = [1, 2, 3]; } catch (err) { expect(err.toString()).toMatch(/TypeError: Incorrect number of tuple elements for tuple_string_int: expected=2, actual=3/i); } myClass.delete(); // Can handle different Number types const withFunction = new m.WithFunction(); expect(withFunction.sum([1, 2, 3.3, 2.0])).toBeCloseTo(8.3, 5); withFunction.delete(); std::vector #include <vector> std::vector<int> getData() { return {0, 1, 2}; } const data = m.getData(); expect(data.size()).toBe(3); for (let i = 0; i < data.size(); i++) { expect(data.get(i)).toBe(i); } data.push_back(3); expect(data.size()).toBe(4); expect(data.get(3)).toBe(3);","title":"Examples"},{"location":"webassembly/examples/#examples","text":"Each example is taken from the test suite for Tolc and, given that you use the latest version, you can expect them all to work. To use WebAssembly from javascript , one has to load it in asynchronously. When using Tolc this is done with a Promise on the javascript side. Each library named MyLib exports a Promise called loadMyLib , in every test the name is simply m for brevity. All tests use jest , and the javascript test boiler plate is omitted: const loadm = require('./build/m'); test('Tolc Test', () => { loadm().then(m => { // The actual javascript example body goes here expect(m.sayTen()).toBe(10); }); });","title":"Examples"},{"location":"webassembly/examples/#classes","text":"#include <string> #include <string_view> class WithConstructor { public: explicit WithConstructor(std::string s) : m_s(s) {} // There is a separate .cpp file containing // int const WithConstructor::i; // To initialize i static int const i = 5; std::string getS() { return m_s; } static int getStatic() { return 55; } private: std::string m_s; }; struct WithMembers { int const i = 5; std::string s = \"hello\"; }; class WithFunction { public: int add(int i, int j) { return i + j; } }; class WithPrivateFunction { double multiply(double i, double j) { return i * j; } }; namespace MyNamespace { struct Nested { int const i = 42; }; } struct WithEnum { enum class Instrument { Guitarr, Flute }; Instrument i = Instrument::Flute; }; // Statics are available without instantiation // Static function expect(m.WithConstructor.getStatic()).toBe(55); // Static variable expect(m.WithConstructor.i).toBe(5); const withConstructor = new m.WithConstructor(\"Hello\"); expect(withConstructor.getS()).toBe(\"Hello\"); // Classes need to be deleted manually withConstructor.delete(); // Const properties are read-only const withMembers = new m.WithMembers(); expect(withMembers.i).toBe(5); try { withMembers.i = 10; expect(true).toBe(false); } catch (err) { expect(err.toString()).toMatch(/BindingError: WithMembers.i is a read-only property/i); } expect(withMembers.s).toBe(\"hello\"); withMembers.delete(); // Public functions are available const withFunction = new m.WithFunction(); expect(withFunction.add(5, 10)).toBe(15); withFunction.delete(); // Cannot access private functions const withPrivateFunction = new m.WithPrivateFunction(); try { withPrivateFunction.multiply(5, 10); expect(true).toBe(false); } catch (err) { expect(err.toString()).toMatch(/TypeError: withPrivateFunction.multiply is not a function/i); } withPrivateFunction.delete(); // Classes can be found under their namespace const nested = new m.MyNamespace.Nested(); expect(nested.i).toBe(42); nested.delete(); // Ok to nest Enums within classes const withEnum = new m.WithEnum(); expect(withEnum.i).toBe(m.WithEnum.Instrument.Flute); withEnum.delete();","title":"Classes"},{"location":"webassembly/examples/#enums","text":"enum Unscoped { Under, Uboat, }; enum class Scoped { Sacred, Snail, }; class EnumTest { public: enum class Inside { One, Two }; explicit EnumTest(Scoped s) : memberEnum(s), inside(Inside::One) {}; Inside inside; Scoped memberEnum; }; Unscoped echo(Unscoped s) { return s; } namespace MyNamespace { enum class Color { Red, Green, Blue }; struct Carrier { enum class Translator { Tolc }; }; } // Can be passed as arguments const snail = m.Scoped.Snail; const enumTest = new m.EnumTest(snail); expect(enumTest.memberEnum).toBe(snail); // Nested enums within classes expect(enumTest.inside).toBe(m.EnumTest.Inside.One); enumTest.delete(); // Unscoped enums work exactly the same const uboat = m.Unscoped.Uboat; expect(m.echo(uboat)).toBe(uboat); // Nested enums inside namespaces const green = m.MyNamespace.Color.Green; expect(green).toBe(m.MyNamespace.Color.Green); // Nested enums inside namespaces inside structs const company = m.MyNamespace.Carrier.Translator.Tolc; expect(company).toBe(m.MyNamespace.Carrier.Translator.Tolc);","title":"Enums"},{"location":"webassembly/examples/#functions","text":"#include <string> int sayTen() { return 10; } std::string giveBack(std::string const& s) { return s; } namespace MyNamespace { int add(int x, int y) { return x + y; } namespace Nested { int increase(int x) { return x + 1; } } } expect(m.sayTen()).toBe(10); expect(m.giveBack(\"hello\")).toBe(\"hello\"); // Nested functions are under their respective namespace expect(m.MyNamespace.add(1, 2)).toBe(3); expect(m.MyNamespace.Nested.increase(2)).toBe(3);","title":"Functions"},{"location":"webassembly/examples/#global-variables","text":"#include <string_view> int const i = 0; double const d = 55; std::string_view const stringView = \"Hello world\"; const char* charPtr = \"Hello world\"; namespace MyNamespace { int const i = 5; } expect(m.i).toBe(0); expect(m.d).toBe(55); // Global strings of type std::string_view and const char* are converted // Globals of type std::string has an open issue: // https://github.com/emscripten-core/emscripten/issues/16275 expect(m.stringView).toBe(\"Hello world\"); expect(m.charPtr).toBe(\"Hello world\"); // Globals within namespaces work expect(m.MyNamespace.i).toBe(5);","title":"Global Variables"},{"location":"webassembly/examples/#namespaces","text":"#include <string> namespace MyLib { int complexFunction() { return 5; } namespace We { namespace Are { namespace Going { namespace Pretty { namespace Deep { std::string meaningOfLife() { return \"42\"; } } } } } } } expect(m.MyLib.complexFunction()).toBe(5); // Namespaces can be nested arbitrarily expect(m.MyLib.We.Are.Going.Pretty.Deep.meaningOfLife()).toBe('42');","title":"Namespaces"},{"location":"webassembly/examples/#overriding-virtual-in-javascript","text":"#include <string> class Animal { public: virtual ~Animal() { } virtual std::string sound(int n_times, bool grumpy) = 0; }; class Dog : public Animal { public: std::string sound(int n_times, bool grumpy) override { if (grumpy) { return \"No.\"; } std::string result; for (int i = 0; i < n_times; ++i) { result += \"woof! \"; } return result; } }; std::string call_sound(Animal *animal) { return animal->sound(3, false); } const fido = new m.Dog(); const grumpy = true; // Overloaded function in C++ expect(fido.sound(1, grumpy)).toBe(\"No.\") expect(fido.sound(1, !grumpy)).toBe(\"woof! \") // Polymorphic function in C++ expect(m.call_sound(fido)).toBe(\"woof! woof! woof! \") fido.delete(); // Inherit from virtual C++ classes in javascript const Cat = m.Animal.extend(\"Animal\", { // Override C++ function sound: function(n_times, grumpy) { return grumpy ? \"No.\" : \"meow! \".repeat(n_times); }, }); const whiskers = new Cat(); // Overloaded C++ function in javascript expect(whiskers.sound(1, grumpy)).toBe(\"No.\") expect(whiskers.sound(1, !grumpy)).toBe(\"meow! \") // Polymorphic function in C++ called with javascript object // Automatic downcasting expect(m.call_sound(whiskers)).toBe(\"meow! meow! meow! \") whiskers.delete(); // Another way is to just provide what is needed // to implement the Animal interface const tiger = m.Animal.implement({ // Put only the functions you want to implement here sound: function(n_times, grumpy) { return grumpy ? \"No.\" : \"roar! \".repeat(n_times); }, }); expect(tiger.sound(1, grumpy)).toBe(\"No.\") expect(tiger.sound(1, !grumpy)).toBe(\"roar! \") // Automatic downcasting works the same expect(m.call_sound(tiger)).toBe(\"roar! roar! roar! \") tiger.delete();","title":"Overriding virtual in javascript"},{"location":"webassembly/examples/#simple-inheritence","text":"#include <string> struct Pet { Pet(const std::string &name) : name(name) { } std::string name; }; struct Dog : public Pet { Dog(const std::string &name) : Pet(name) { } std::string bark() const { return \"woof!\"; } }; const fido = new m.Dog(\"Fido\"); // Inherits public properties expect(fido.name).toBe(\"Fido\") // But has its new functions expect(fido.bark()).toBe(\"woof!\")","title":"Simple inheritence"},{"location":"webassembly/examples/#smart-pointers","text":"#include <memory> struct Example { int m_value = 5; }; struct ExampleShared { int m_value = 10; }; std::unique_ptr<Example> create_unique() { return std::make_unique<Example>(); } std::shared_ptr<ExampleShared> create_shared() { return std::make_shared<ExampleShared>(); } // Note: Embind only supports *return*-values of std::unique_ptr // An argument of type std::unique_ptr<T> will return in an error message // std::unique_ptr just corresponds to the value u = m.create_unique(); expect(u.m_value).toBe(5); u.delete(); // std::shared_ptr also just corresponds to the value s = m.create_shared(); expect(s.m_value).toBe(10); s.delete();","title":"Smart Pointers"},{"location":"webassembly/examples/#stdarray","text":"#include <array> #include <string> std::array<double, 3> getData3() { return {0.0, 1.0, 2.0}; } // Multiple array types at the same time std::array<int, 2> getData2() { return {0, 1}; } const data3 = m.getData3(); // It's just a normal JS array expect(data3.length).toBe(3); expect(data3).toStrictEqual([0, 1, 2]); const data2 = m.getData2(); expect(data2.length).toBe(2); expect(data2).toStrictEqual([0, 1]);","title":"std::array"},{"location":"webassembly/examples/#stdmap","text":"#include <map> #include <string> std::map<int, std::string> getData() { std::map<int, std::string> m; m.insert({10, \"hello\"}); return m; } const data = m.getData(); expect(data.size()).toBe(1); expect(data.get(10)).toBe(\"hello\"); data.set(50, \"Stuff\"); expect(data.size()).toBe(2); expect(data.get(50)).toBe(\"Stuff\");","title":"std::map"},{"location":"webassembly/examples/#stdpair","text":"#include <string> class MyClass { public: explicit MyClass(std::pair<std::string, int> s) : m_s(s) {} std::pair<std::string, int> getS() { return m_s; } private: std::pair<std::string, int> m_s; }; class WithFunction { public: int sum(std::pair<int, int> v) { return v.first + v.second; } }; // On the javascript side, std::pair<std::string, int> is a basic array const myArray = [\"hi\", 4]; withMember = new m.MyClass(myArray); expect(withMember.getS()).toStrictEqual(myArray); withMember.delete(); const withFunction = new m.WithFunction() expect(withFunction.sum([1, 2])).toBe(3) withFunction.delete();","title":"std::pair"},{"location":"webassembly/examples/#stdtuple","text":"#include <string> #include <tuple> class MyClass { public: explicit MyClass(std::tuple<std::string, int> _tuple) : m_tuple(_tuple) {} std::tuple<std::string, int> getTuple() { return m_tuple; } std::tuple<std::string, int> m_tuple; }; class WithFunction { public: double sum(std::tuple<int, int, float, double> t) { return std::get<0>(t) + std::get<1>(t) + std::get<2>(t) + std::get<3>(t); } }; // Tuple converts from javascript array const myArray = [\"Hello World\", 42]; const myClass = new m.MyClass(myArray); expect(myClass.getTuple()).toStrictEqual(myArray); // The array still need to match the underlying std::tuple structure try { // m_tuple is public myClass.m_tuple = [1, 2, 3]; } catch (err) { expect(err.toString()).toMatch(/TypeError: Incorrect number of tuple elements for tuple_string_int: expected=2, actual=3/i); } myClass.delete(); // Can handle different Number types const withFunction = new m.WithFunction(); expect(withFunction.sum([1, 2, 3.3, 2.0])).toBeCloseTo(8.3, 5); withFunction.delete();","title":"std::tuple"},{"location":"webassembly/examples/#stdvector","text":"#include <vector> std::vector<int> getData() { return {0, 1, 2}; } const data = m.getData(); expect(data.size()).toBe(3); for (let i = 0; i < data.size(); i++) { expect(data.get(i)).toBe(i); } data.push_back(3); expect(data.size()).toBe(4); expect(data.get(3)).toBe(3);","title":"std::vector"},{"location":"webassembly/faq/","text":"FAQ A note on const within containers As of writing Embind does not support const within the template parameter list of most standard containers (e.g. std::map<int, const std::string> or std::pair<const int, int> ). These will be ignored from the output.","title":"FAQ #"},{"location":"webassembly/faq/#faq","text":"","title":"FAQ"},{"location":"webassembly/faq/#a-note-on-const-within-containers","text":"As of writing Embind does not support const within the template parameter list of most standard containers (e.g. std::map<int, const std::string> or std::pair<const int, int> ). These will be ignored from the output.","title":"A note on const within containers"},{"location":"webassembly/introduction/","text":"WebAssembly with Tolc In order for C++ to be called from javascript there has to be an interface level. tolc generates this level from your already written C++ interface. To be as close to what an engineer would have written, tolc generates human readable embind . This is then compiled to a .wasm and a .js file that javascript can import. Using a C++ library from javascript This is a quick guide to using a C++ library (here called MyLib ) from javascript . We will: Download and use Tolc Download and set up Emscripten Use the resulting WebAssembly from javascript The following works on all supported platforms. On all platforms you need git available in your path . Commands that should be run from a terminal starts with $ , while comments starts with # . Downloading Tolc Just add the following in a CMakeLists.txt below where the library you intend to use from javascript is defined: # Download Tolc # Can be [\"latest\", \"v0.2.0\", ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) tolc_create_bindings( TARGET MyLib LANGUAGE wasm OUTPUT wasm-bindings ) Assuming your library is called MyLib , and the bindings should be generated to the directory wasm-bindings . Downloading Emscripten In order to compile your library to WebAssembly , you need to download the Emscripten compiler . This is typically done via the Emscripten SDK . Navigate to the directory where you want to install and run the following commands: # Download SDK $ git clone https://github.com/emscripten-core/emsdk.git $ cd emsdk Now follow the specifig commands for your platform. Linux/MacOS From within the emsdk directory: # Download and install locally $ ./emsdk install 3.1.3 # Writes configuration file .emscripten $ ./emsdk activate 3.1.3 Windows From within the emsdk directory: # Download and install locally $ emsdk.bat install 3.1.3 # Writes configuration file .emscripten $ emsdk.bat activate 3.1.3 Configuring Your Project Since CMake doesn't have native support for WebAssembly we have to provide a toolchain file, fortunately for us, Emscripten provides us with one. When configuring your CMake project, just pass the toolchain flag -DCMAKE_TOOLCHAIN_FILE=${EMSDK_DIRECTORY}/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake . Where you need to replace ${EMSDK_DIRECTORY} with the directory of the previously downloaded Emscripten SDK . Note that the directory separator used by CMake is always forward slash ( / ), even on Windows. Example: # Configures project to build using Emscripten $ cmake -S. -Bbuild -DCMAKE_TOOLCHAIN_FILE=${EMSDK_DIRECTORY}/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake Using From javascript Looking into build/tolc you should see MyLib.js aswell as MyLib.wasm . MyLib.js exports a Promise that loads the built WebAssembly . Here is an example usage: // run.js const loadMyLib = require('./build/MyLib'); loadMyLib().then(MyLib => { // From here you can use the C++ functions of your library as usual MyLib.myCppFunction(); }); Running the file as normal: $ node run.js Using from a web page By default Emscripten assumes that you're running your code in a node environment (e.g. having access to the filesystem). This is not the case on a web page served to a browser. If we add the link flag -s ENVIRONMENT='web' to Emscripten it will produce a serveable WebAssembly module. Since Tolc exposes a CMake build target for the module, all we have to do is add the flag ourself: # Creates the CMake target ${TARGET}_${LANGUAGE} # In this case: MyLib_wasm tolc_create_bindings( TARGET MyLib LANGUAGE wasm OUTPUT wasm-bindings ) # Want to deploy to a web page set_property( TARGET MyLib_wasm APPEND_STRING PROPERTY LINK_FLAGS \"-s ENVIRONMENT='web'\") Then we copy over MyLib.js and MyLib.wasm to our web application and load them as shown previously: // app.js const loadMyLib = require('./MyLib'); loadMyLib().then(MyLib => { // From here you can use the C++ functions of your library as usual MyLib.myCppFunction(); }); Assuming you've loaded the javascript within your page: <!-- index.html --> ... <head> <script type=\"text/javascript\" src=\"./app.js\"></script> </head> ... For a complete example you can see the Tolc-demo repository: https://github.com/Tolc-Software/tolc-demo . If you want to see what more is supported you can take a look at the Examples section .","title":"WebAssembly with Tolc #"},{"location":"webassembly/introduction/#webassembly-with-tolc","text":"In order for C++ to be called from javascript there has to be an interface level. tolc generates this level from your already written C++ interface. To be as close to what an engineer would have written, tolc generates human readable embind . This is then compiled to a .wasm and a .js file that javascript can import.","title":"WebAssembly with Tolc"},{"location":"webassembly/introduction/#using-a-c-library-from-javascript","text":"This is a quick guide to using a C++ library (here called MyLib ) from javascript . We will: Download and use Tolc Download and set up Emscripten Use the resulting WebAssembly from javascript The following works on all supported platforms. On all platforms you need git available in your path . Commands that should be run from a terminal starts with $ , while comments starts with # .","title":"Using a C++ library from javascript"},{"location":"webassembly/introduction/#downloading-tolc","text":"Just add the following in a CMakeLists.txt below where the library you intend to use from javascript is defined: # Download Tolc # Can be [\"latest\", \"v0.2.0\", ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) tolc_create_bindings( TARGET MyLib LANGUAGE wasm OUTPUT wasm-bindings ) Assuming your library is called MyLib , and the bindings should be generated to the directory wasm-bindings .","title":"Downloading Tolc"},{"location":"webassembly/introduction/#downloading-emscripten","text":"In order to compile your library to WebAssembly , you need to download the Emscripten compiler . This is typically done via the Emscripten SDK . Navigate to the directory where you want to install and run the following commands: # Download SDK $ git clone https://github.com/emscripten-core/emsdk.git $ cd emsdk Now follow the specifig commands for your platform.","title":"Downloading Emscripten"},{"location":"webassembly/introduction/#linuxmacos","text":"From within the emsdk directory: # Download and install locally $ ./emsdk install 3.1.3 # Writes configuration file .emscripten $ ./emsdk activate 3.1.3","title":"Linux/MacOS"},{"location":"webassembly/introduction/#windows","text":"From within the emsdk directory: # Download and install locally $ emsdk.bat install 3.1.3 # Writes configuration file .emscripten $ emsdk.bat activate 3.1.3","title":"Windows"},{"location":"webassembly/introduction/#configuring-your-project","text":"Since CMake doesn't have native support for WebAssembly we have to provide a toolchain file, fortunately for us, Emscripten provides us with one. When configuring your CMake project, just pass the toolchain flag -DCMAKE_TOOLCHAIN_FILE=${EMSDK_DIRECTORY}/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake . Where you need to replace ${EMSDK_DIRECTORY} with the directory of the previously downloaded Emscripten SDK . Note that the directory separator used by CMake is always forward slash ( / ), even on Windows. Example: # Configures project to build using Emscripten $ cmake -S. -Bbuild -DCMAKE_TOOLCHAIN_FILE=${EMSDK_DIRECTORY}/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake","title":"Configuring Your Project"},{"location":"webassembly/introduction/#using-from-javascript","text":"Looking into build/tolc you should see MyLib.js aswell as MyLib.wasm . MyLib.js exports a Promise that loads the built WebAssembly . Here is an example usage: // run.js const loadMyLib = require('./build/MyLib'); loadMyLib().then(MyLib => { // From here you can use the C++ functions of your library as usual MyLib.myCppFunction(); }); Running the file as normal: $ node run.js","title":"Using From javascript"},{"location":"webassembly/introduction/#using-from-a-web-page","text":"By default Emscripten assumes that you're running your code in a node environment (e.g. having access to the filesystem). This is not the case on a web page served to a browser. If we add the link flag -s ENVIRONMENT='web' to Emscripten it will produce a serveable WebAssembly module. Since Tolc exposes a CMake build target for the module, all we have to do is add the flag ourself: # Creates the CMake target ${TARGET}_${LANGUAGE} # In this case: MyLib_wasm tolc_create_bindings( TARGET MyLib LANGUAGE wasm OUTPUT wasm-bindings ) # Want to deploy to a web page set_property( TARGET MyLib_wasm APPEND_STRING PROPERTY LINK_FLAGS \"-s ENVIRONMENT='web'\") Then we copy over MyLib.js and MyLib.wasm to our web application and load them as shown previously: // app.js const loadMyLib = require('./MyLib'); loadMyLib().then(MyLib => { // From here you can use the C++ functions of your library as usual MyLib.myCppFunction(); }); Assuming you've loaded the javascript within your page: <!-- index.html --> ... <head> <script type=\"text/javascript\" src=\"./app.js\"></script> </head> ... For a complete example you can see the Tolc-demo repository: https://github.com/Tolc-Software/tolc-demo . If you want to see what more is supported you can take a look at the Examples section .","title":"Using from a web page"},{"location":"webassembly/overloaded_functions_naming_convention/","text":"Overloaded Functions Naming Convention When creating bindings for a function f tolc will choose a name based on if the function is overloaded or not. For example: double f(); double f(int); The two functions will be available from javascript as f and f_int respectively. const loadMyLib = require('./myLib.js'); loadMyLib().then(MyLib => { const result0 = MyLib.f(); const result1 = MyLib.f_int(); }); Multiple arguments are added to the name as joined separated with an underscore ( _ ). The names are meant to be as predictable as possible. The rules are the same as for the template naming conventions .","title":"Overloaded Functions Naming Convention #"},{"location":"webassembly/overloaded_functions_naming_convention/#overloaded-functions-naming-convention","text":"When creating bindings for a function f tolc will choose a name based on if the function is overloaded or not. For example: double f(); double f(int); The two functions will be available from javascript as f and f_int respectively. const loadMyLib = require('./myLib.js'); loadMyLib().then(MyLib => { const result0 = MyLib.f(); const result1 = MyLib.f_int(); }); Multiple arguments are added to the name as joined separated with an underscore ( _ ). The names are meant to be as predictable as possible. The rules are the same as for the template naming conventions .","title":"Overloaded Functions Naming Convention"},{"location":"webassembly/quickstart/","text":"WebAssembly with Tolc In order for C++ to be called from javascript there has to be an interface level. tolc generates this level from your already written C++ interface. To be as close to what an engineer would have written, tolc generates human readable embind . This is then compiled to a .wasm and a .js file that javascript can import. Using a C++ library from javascript This is a quick guide to using a C++ library (here called MyLib ) from javascript . We will: Download and use Tolc Download and set up Emscripten Use the resulting WebAssembly from javascript The following works on all supported platforms. On all platforms you need git available in your path . Commands that should be run from a terminal starts with $ , while comments starts with # . Downloading Tolc Just add the following in a CMakeLists.txt below where the library you intend to use from javascript is defined: # Download Tolc # Can be [\"latest\", \"v0.2.0\", ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) tolc_create_bindings( TARGET MyLib LANGUAGE wasm OUTPUT wasm-bindings ) Assuming your library is called MyLib , and the bindings should be generated to the directory wasm-bindings . Downloading Emscripten In order to compile your library to WebAssembly , you need to download the Emscripten compiler . This is typically done via the Emscripten SDK . Navigate to the directory where you want to install and run the following commands: # Download SDK $ git clone https://github.com/emscripten-core/emsdk.git $ cd emsdk Now follow the specifig commands for your platform. Linux/MacOS From within the emsdk directory: # Download and install locally $ ./emsdk install 3.1.3 # Writes configuration file .emscripten $ ./emsdk activate 3.1.3 Windows From within the emsdk directory: # Download and install locally $ emsdk.bat install 3.1.3 # Writes configuration file .emscripten $ emsdk.bat activate 3.1.3 Configuring Your Project Since CMake doesn't have native support for WebAssembly we have to provide a toolchain file, fortunately for us, Emscripten provides us with one. When configuring your CMake project, just pass the toolchain flag -DCMAKE_TOOLCHAIN_FILE=${EMSDK_DIRECTORY}/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake . Where you need to replace ${EMSDK_DIRECTORY} with the directory of the previously downloaded Emscripten SDK . Note that the directory separator used by CMake is always forward slash ( / ), even on Windows. Example: # Configures project to build using Emscripten $ cmake -S. -Bbuild -DCMAKE_TOOLCHAIN_FILE=${EMSDK_DIRECTORY}/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake Using From javascript Looking into build/tolc you should see MyLib.js aswell as MyLib.wasm . MyLib.js exports a Promise that loads the built WebAssembly . Here is an example usage: // run.js const loadMyLib = require('./build/MyLib'); loadMyLib().then(MyLib => { // From here you can use the C++ functions of your library as usual MyLib.myCppFunction(); }); Running the file as normal: $ node run.js Using from a web page By default Emscripten assumes that you're running your code in a node environment (e.g. having access to the filesystem). This is not the case on a web page served to a browser. If we add the link flag -s ENVIRONMENT='web' to Emscripten it will produce a serveable WebAssembly module. Since Tolc exposes a CMake build target for the module, all we have to do is add the flag ourself: # Creates the CMake target ${TARGET}_${LANGUAGE} # In this case: MyLib_wasm tolc_create_bindings( TARGET MyLib LANGUAGE wasm OUTPUT wasm-bindings ) # Want to deploy to a web page set_property( TARGET MyLib_wasm APPEND_STRING PROPERTY LINK_FLAGS \"-s ENVIRONMENT='web'\") Then we copy over MyLib.js and MyLib.wasm to our web application and load them as shown previously: // app.js const loadMyLib = require('./MyLib'); loadMyLib().then(MyLib => { // From here you can use the C++ functions of your library as usual MyLib.myCppFunction(); }); Assuming you've loaded the javascript within your page: <!-- index.html --> ... <head> <script type=\"text/javascript\" src=\"./app.js\"></script> </head> ... For a complete example you can see the Tolc-demo repository: https://github.com/Tolc-Software/tolc-demo . If you want to see what more is supported you can take a look at the Examples section .","title":"Quickstart"},{"location":"webassembly/quickstart/#webassembly-with-tolc","text":"In order for C++ to be called from javascript there has to be an interface level. tolc generates this level from your already written C++ interface. To be as close to what an engineer would have written, tolc generates human readable embind . This is then compiled to a .wasm and a .js file that javascript can import.","title":"WebAssembly with Tolc"},{"location":"webassembly/quickstart/#using-a-c-library-from-javascript","text":"This is a quick guide to using a C++ library (here called MyLib ) from javascript . We will: Download and use Tolc Download and set up Emscripten Use the resulting WebAssembly from javascript The following works on all supported platforms. On all platforms you need git available in your path . Commands that should be run from a terminal starts with $ , while comments starts with # .","title":"Using a C++ library from javascript"},{"location":"webassembly/quickstart/#downloading-tolc","text":"Just add the following in a CMakeLists.txt below where the library you intend to use from javascript is defined: # Download Tolc # Can be [\"latest\", \"v0.2.0\", ...] set(tolc_version latest) include(FetchContent) FetchContent_Declare( tolc_entry URL https://github.com/Tolc-Software/tolc/releases/download/${tolc_version}/tolc-${CMAKE_HOST_SYSTEM_NAME}.tar.xz ) FetchContent_Populate(tolc_entry) set(tolc_DIR ${tolc_entry_SOURCE_DIR}/lib/cmake/tolc) find_package( tolc CONFIG REQUIRED ) tolc_create_bindings( TARGET MyLib LANGUAGE wasm OUTPUT wasm-bindings ) Assuming your library is called MyLib , and the bindings should be generated to the directory wasm-bindings .","title":"Downloading Tolc"},{"location":"webassembly/quickstart/#downloading-emscripten","text":"In order to compile your library to WebAssembly , you need to download the Emscripten compiler . This is typically done via the Emscripten SDK . Navigate to the directory where you want to install and run the following commands: # Download SDK $ git clone https://github.com/emscripten-core/emsdk.git $ cd emsdk Now follow the specifig commands for your platform.","title":"Downloading Emscripten"},{"location":"webassembly/quickstart/#linuxmacos","text":"From within the emsdk directory: # Download and install locally $ ./emsdk install 3.1.3 # Writes configuration file .emscripten $ ./emsdk activate 3.1.3","title":"Linux/MacOS"},{"location":"webassembly/quickstart/#windows","text":"From within the emsdk directory: # Download and install locally $ emsdk.bat install 3.1.3 # Writes configuration file .emscripten $ emsdk.bat activate 3.1.3","title":"Windows"},{"location":"webassembly/quickstart/#configuring-your-project","text":"Since CMake doesn't have native support for WebAssembly we have to provide a toolchain file, fortunately for us, Emscripten provides us with one. When configuring your CMake project, just pass the toolchain flag -DCMAKE_TOOLCHAIN_FILE=${EMSDK_DIRECTORY}/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake . Where you need to replace ${EMSDK_DIRECTORY} with the directory of the previously downloaded Emscripten SDK . Note that the directory separator used by CMake is always forward slash ( / ), even on Windows. Example: # Configures project to build using Emscripten $ cmake -S. -Bbuild -DCMAKE_TOOLCHAIN_FILE=${EMSDK_DIRECTORY}/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake","title":"Configuring Your Project"},{"location":"webassembly/quickstart/#using-from-javascript","text":"Looking into build/tolc you should see MyLib.js aswell as MyLib.wasm . MyLib.js exports a Promise that loads the built WebAssembly . Here is an example usage: // run.js const loadMyLib = require('./build/MyLib'); loadMyLib().then(MyLib => { // From here you can use the C++ functions of your library as usual MyLib.myCppFunction(); }); Running the file as normal: $ node run.js","title":"Using From javascript"},{"location":"webassembly/quickstart/#using-from-a-web-page","text":"By default Emscripten assumes that you're running your code in a node environment (e.g. having access to the filesystem). This is not the case on a web page served to a browser. If we add the link flag -s ENVIRONMENT='web' to Emscripten it will produce a serveable WebAssembly module. Since Tolc exposes a CMake build target for the module, all we have to do is add the flag ourself: # Creates the CMake target ${TARGET}_${LANGUAGE} # In this case: MyLib_wasm tolc_create_bindings( TARGET MyLib LANGUAGE wasm OUTPUT wasm-bindings ) # Want to deploy to a web page set_property( TARGET MyLib_wasm APPEND_STRING PROPERTY LINK_FLAGS \"-s ENVIRONMENT='web'\") Then we copy over MyLib.js and MyLib.wasm to our web application and load them as shown previously: // app.js const loadMyLib = require('./MyLib'); loadMyLib().then(MyLib => { // From here you can use the C++ functions of your library as usual MyLib.myCppFunction(); }); Assuming you've loaded the javascript within your page: <!-- index.html --> ... <head> <script type=\"text/javascript\" src=\"./app.js\"></script> </head> ... For a complete example you can see the Tolc-demo repository: https://github.com/Tolc-Software/tolc-demo . If you want to see what more is supported you can take a look at the Examples section .","title":"Using from a web page"},{"location":"webassembly/template_naming_convention/","text":"Template Naming Convention When creating bindings for a templated class tolc will choose a name based on the template parameters. For example: template <typename T> class Example { public: T f(T type) { return type; } }; template class Example<int>; The specialized class Example<int> will be available from javascript as Example_int : const loadMyLib = require('./build/MyLib'); loadm().then(MyLib => { example = new MyLib.Example_int(); // Prints 5 print(example.f(5)) example.delete(); }); Multiple template parameters are separated with an underscore (_). The names are meant to be as predictable as possible. The rules are: std:: is removed from any standard library type. _ is removed from any standard library type. User defined types are left untouched (i.e. the class MyNamespace::MyClass will result in appending MyClass ). Type to string conversions C++ type Resulting name std::array array std::complex complex std::deque deque std::filesystem::path path std::forward_list forwardlist std::function function std::list list std::map map std::multimap multimap std::multiset multiset std::optional optional std::pair pair std::priority_queue priorityqueue std::queue queue std::set set std::shared_ptr sharedptr std::stack stack std::tuple tuple std::unique_ptr uniqueptr std::unordered_map unorderedmap std::unordered_multimap unorderedmultimap std::unordered_multiset unorderedmultiset std::unordered_set unorderedset std::valarray valarray std::variant variant std::vector vector bool bool char char char16_t char16t char32_t char32t double double float float int int Integral Integral literal* long double longdouble long int longint long long int longlongint short int shortint signed char signedchar string string string_view stringview unsigned char unsignedchar unsigned int unsignedint unsigned long int unsignedlongint unsigned long long int unsignedlonglongint unsigned short int unsignedshortint wchar_t wchart * For example the 3 in MyClass<std::array<int, 3>> results in MyClass_array_int_3 .","title":"Template Naming Convention #"},{"location":"webassembly/template_naming_convention/#template-naming-convention","text":"When creating bindings for a templated class tolc will choose a name based on the template parameters. For example: template <typename T> class Example { public: T f(T type) { return type; } }; template class Example<int>; The specialized class Example<int> will be available from javascript as Example_int : const loadMyLib = require('./build/MyLib'); loadm().then(MyLib => { example = new MyLib.Example_int(); // Prints 5 print(example.f(5)) example.delete(); }); Multiple template parameters are separated with an underscore (_). The names are meant to be as predictable as possible. The rules are: std:: is removed from any standard library type. _ is removed from any standard library type. User defined types are left untouched (i.e. the class MyNamespace::MyClass will result in appending MyClass ).","title":"Template Naming Convention"},{"location":"webassembly/template_naming_convention/#type-to-string-conversions","text":"C++ type Resulting name std::array array std::complex complex std::deque deque std::filesystem::path path std::forward_list forwardlist std::function function std::list list std::map map std::multimap multimap std::multiset multiset std::optional optional std::pair pair std::priority_queue priorityqueue std::queue queue std::set set std::shared_ptr sharedptr std::stack stack std::tuple tuple std::unique_ptr uniqueptr std::unordered_map unorderedmap std::unordered_multimap unorderedmultimap std::unordered_multiset unorderedmultiset std::unordered_set unorderedset std::valarray valarray std::variant variant std::vector vector bool bool char char char16_t char16t char32_t char32t double double float float int int Integral Integral literal* long double longdouble long int longint long long int longlongint short int shortint signed char signedchar string string string_view stringview unsigned char unsignedchar unsigned int unsignedint unsigned long int unsignedlongint unsigned long long int unsignedlonglongint unsigned short int unsignedshortint wchar_t wchart * For example the 3 in MyClass<std::array<int, 3>> results in MyClass_array_int_3 .","title":"Type to string conversions"}]}